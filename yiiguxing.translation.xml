<application>
  <component name="AppStorage">
    <option name="newTranslationDialogWidth" value="508" />
    <option name="newTranslationDialogX" value="755" />
    <option name="newTranslationDialogY" value="517" />
    <histories>
      <item value="内部" />
      <item value="提取" />
      <item value="获取" />
      <item value="解析" />
      <item value="递归" />
      <item value="perform Unconditional Rewrites" />
      <item value="channel Active" />
      <item value="channel Inactive" />
      <item value="timeout Seconds" />
      <item value="List of non-reserved keywords to add; items in this list become non-reserved" />
      <item value="reserved" />
      <item value="List of keywords from &quot;keywords&quot; section that are not reserved." />
      <item value="List of new keywords. Example: &quot;DATABASES&quot;, &quot;TABLES&quot;. If the keyword is not a reserved keyword add it to 'nonReservedKeywords' section." />
      <item value="non Reserved Keywords" />
      <item value="for Each Remaining" />
      <item value="notify Changed" />
      <item value="fire" />
      <item value="fire Property Change" />
      <item value="snapshot" />
      <item value="in Operation Coercion" />
      <item value="user Defined Function Coercion" />
      <item value="query Source Coercion" />
      <item value="coerce Source Row Type" />
      <item value="case When Coercion" />
      <item value="pairs" />
      <item value="Returns whether to enable rewrite of &quot;macro-like&quot; calls such as COALESCE." />
      <item value="Sets whether to enable rewrite of &quot;macro-like&quot; calls such as COALESCE." />
      <item value="with Call Rewrite" />
      <item value="Returns the dialect of SQL (SQL:2003, etc.) this validator recognizes. Default is {@link SqlConformanceEnumDEFAULT}." />
      <item value="Fix parse and resultset bugs." />
      <item value="Strict For Wall" />
      <item value="Optimized For For Parameterized Skip Value" />
      <item value="Optimized For Parameterized" />
      <item value="Keep Insert Value Clause Original String" />
      <item value="Keep Select List Original String" />
      <item value="Use Insert Columns Cache" />
      <item value="Enable SQL Binary Op Expr Group" />
      <item value="LOOKAHEAD" />
      <item value="Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:www.apache.orglicensesLICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. &lt;@pp.dropOutputFile &gt; &lt;@pp.changeOutputFile name=&quot;javaccParser.jj&quot; &gt; options { STATIC = true; CACHE_TOKEN = true; IGNORE_CASE = true; UNICODE_INPUT = true; } PARSER_BEGIN({parser.class}) package {parser.package}; &lt;list (parser.imports!default.parser.imports) as importStr&gt; import {importStr}; &lt;list&gt; import org.apache.calcite.avatica.util.Casing; import org.apache.calcite.avatica.util.DateTimeUtils; import org.apache.calcite.avatica.util.TimeUnit; import org.apache.calcite.rel.type.RelDataType; import org.apache.calcite.runtime.CalciteContextException; import org.apache.calcite.sql.JoinConditionType; import org.apache.calcite.sql.JoinType; import org.apache.calcite.sql.SqlAlter; import org.apache.calcite.sql.SqlBasicTypeNameSpec; import org.apache.calcite.sql.SqlBinaryOperator; import org.apache.calcite.sql.SqlCall; import org.apache.calcite.sql.SqlCharStringLiteral; import org.apache.calcite.sql.SqlCollation; import org.apache.calcite.sql.SqlCollectionTypeNameSpec; import org.apache.calcite.sql.SqlDataTypeSpec; import org.apache.calcite.sql.SqlDateLiteral; import org.apache.calcite.sql.SqlDelete; import org.apache.calcite.sql.SqlDescribeSchema; import org.apache.calcite.sql.SqlDescribeTable; import org.apache.calcite.sql.SqlDynamicParam; import org.apache.calcite.sql.SqlExplain; import org.apache.calcite.sql.SqlExplainFormat; import org.apache.calcite.sql.SqlExplainLevel; import org.apache.calcite.sql.SqlFunction; import org.apache.calcite.sql.SqlFunctionCategory; import org.apache.calcite.sql.SqlHint; import org.apache.calcite.sql.SqlIdentifier; import org.apache.calcite.sql.SqlInsert; import org.apache.calcite.sql.SqlInsertKeyword; import org.apache.calcite.sql.SqlIntervalLiteral; import org.apache.calcite.sql.SqlIntervalQualifier; import org.apache.calcite.sql.SqlJdbcDataTypeName; import org.apache.calcite.sql.SqlJdbcFunctionCall; import org.apache.calcite.sql.SqlJoin; import org.apache.calcite.sql.SqlJsonConstructorNullClause; import org.apache.calcite.sql.SqlJsonEncoding; import org.apache.calcite.sql.SqlJsonExistsErrorBehavior; import org.apache.calcite.sql.SqlJsonEmptyOrError; import org.apache.calcite.sql.SqlJsonQueryEmptyOrErrorBehavior; import org.apache.calcite.sql.SqlJsonQueryWrapperBehavior; import org.apache.calcite.sql.SqlJsonValueEmptyOrErrorBehavior; import org.apache.calcite.sql.SqlJsonValueReturning; import org.apache.calcite.sql.SqlKind; import org.apache.calcite.sql.SqlLiteral; import org.apache.calcite.sql.SqlMatchRecognize; import org.apache.calcite.sql.SqlMerge; import org.apache.calcite.sql.SqlNode; import org.apache.calcite.sql.SqlNodeList; import org.apache.calcite.sql.SqlNumericLiteral; import org.apache.calcite.sql.SqlOperator; import org.apache.calcite.sql.SqlOrderBy; import org.apache.calcite.sql.SqlPivot; import org.apache.calcite.sql.SqlPostfixOperator; import org.apache.calcite.sql.SqlPrefixOperator; import org.apache.calcite.sql.SqlRowTypeNameSpec; import org.apache.calcite.sql.SqlSampleSpec; import org.apache.calcite.sql.SqlSelect; import org.apache.calcite.sql.SqlSelectKeyword; import org.apache.calcite.sql.SqlSetOption; import org.apache.calcite.sql.SqlSnapshot; import org.apache.calcite.sql.SqlTableRef; import org.apache.calcite.sql.SqlTimeLiteral; import org.apache.calcite.sql.SqlTimestampLiteral; import org.apache.calcite.sql.SqlTypeNameSpec; import org.apache.calcite.sql.SqlUnnestOperator; import org.apache.calcite.sql.SqlUpdate; import org.apache.calcite.sql.SqlUserDefinedTypeNameSpec; import org.apache.calcite.sql.SqlUtil; import org.apache.calcite.sql.SqlWindow; import org.apache.calcite.sql.SqlWith; import org.apache.calcite.sql.SqlWithItem; import org.apache.calcite.sql.fun.SqlCase; import org.apache.calcite.sql.fun.SqlLibraryOperators; import org.apache.calcite.sql.fun.SqlStdOperatorTable; import org.apache.calcite.sql.fun.SqlTrimFunction; import org.apache.calcite.sql.parser.Span; import org.apache.calcite.sql.parser.SqlAbstractParserImpl; import org.apache.calcite.sql.parser.SqlParseException; import org.apache.calcite.sql.parser.SqlParser; import org.apache.calcite.sql.parser.SqlParserImplFactory; import org.apache.calcite.sql.parser.SqlParserPos; import org.apache.calcite.sql.parser.SqlParserUtil; import org.apache.calcite.sql.type.SqlTypeName; import org.apache.calcite.sql.validate.SqlConformance; import org.apache.calcite.util.Glossary; import org.apache.calcite.util.NlsString; import org.apache.calcite.util.Pair; import org.apache.calcite.util.SourceStringReader; import org.apache.calcite.util.Util; import org.apache.calcite.util.trace.CalciteTrace; import org.slf4j.Logger; import java.io.Reader; import java.math.BigDecimal; import java.util.ArrayList; import java.util.Arrays; import java.util.Calendar; import java.util.Collections; import java.util.List; import java.util.Locale; import static org.apache.calcite.util.Static.RESOURCE; SQL parser, generated from Parser.jj by JavaCC. &lt;p&gt;The public wrapper for this parser is {@link SqlParser}. public class {parser.class} extends SqlAbstractParserImpl { private static final Logger LOGGER = CalciteTrace.getParserTracer(); Can't use quoted literal because of a bug in how JavaCC translates backslash-backslash. private static final char BACKSLASH = 0x5c; private static final char DOUBLE_QUOTE = 0x22; private static final String DQ = DOUBLE_QUOTE + &quot;&quot;; private static final String DQDQ = DQ + DQ; private static Metadata metadata; private Casing unquotedCasing; private Casing quotedCasing; private int identifierMaxLength; private SqlConformance conformance; {@link SqlParserImplFactory} implementation for creating parser. public static final SqlParserImplFactory FACTORY = new SqlParserImplFactory() { public SqlAbstractParserImpl getParser(Reader reader) { final {parser.class} parser = new {parser.class}(reader); if (reader instanceof SourceStringReader) { final String sql = ((SourceStringReader) reader).getSourceString(); parser.setOriginalSql(sql); } return parser; } }; public SqlParseException normalizeException(Throwable ex) { try { if (ex instanceof ParseException) { ex = cleanupParseException((ParseException) ex); } return convertException(ex); } catch (ParseException e) { throw new AssertionError(e); } } public Metadata getMetadata() { synchronized ({parser.class}.class) { if (metadata == null) { metadata = new MetadataImpl( new {parser.class}(new java.io.StringReader(&quot;&quot;))); } return metadata; } } public void setTabSize(int tabSize) { jj_input_stream.setTabSize(tabSize); } public void switchTo(SqlAbstractParserImpl.LexicalState state) { final int stateOrdinal = Arrays.asList({parser.class}TokenManager.lexStateNames) .indexOf(state.name()); token_source.SwitchTo(stateOrdinal); } public void setQuotedCasing(Casing quotedCasing) { this.quotedCasing = quotedCasing; } public void setUnquotedCasing(Casing unquotedCasing) { this.unquotedCasing = unquotedCasing; } public void setIdentifierMaxLength(int identifierMaxLength) { this.identifierMaxLength = identifierMaxLength; } public void setConformance(SqlConformance conformance) { this.conformance = conformance; } public SqlNode parseSqlExpressionEof() throws Exception { return SqlExpressionEof(); } public SqlNode parseSqlStmtEof() throws Exception { return SqlStmtEof(); } public SqlNodeList parseSqlStmtList() throws Exception { return SqlStmtList(); } private SqlNode extend(SqlNode table, SqlNodeList extendList) { return SqlStdOperatorTable.EXTEND.createCall( Span.of(table, extendList).pos(), table, extendList); } Adds a warning that a token such as &quot;HOURS&quot; was used, whereas the SQL standard only allows &quot;HOUR&quot;. &lt;p&gt;Currently, we silently add an exception to a list of warnings. In future, we may have better compliance checking, for example a strict compliance mode that throws if any non-standard features are used. private TimeUnit warn(TimeUnit timeUnit) throws ParseException { final String token = getToken(0).image.toUpperCase(Locale.ROOT); warnings.add( SqlUtil.newContextException(getPos(), RESOURCE.nonStandardFeatureUsed(token))); return timeUnit; } } PARSER_END({parser.class}) Utility Codes for Semantic Analysis For Debug JAVACODE void debug_message1() { LOGGER.info(&quot;{} , {}&quot;, getToken(0).image, getToken(1).image); } JAVACODE String unquotedIdentifier() { return SqlParserUtil.strip(getToken(0).image, null, null, null, unquotedCasing); } Allows parser to be extended with new types of table references. The default implementation of this production is empty. SqlNode ExtendedTableRef() : { } { UnusedExtension() { return null; } } Allows an OVER clause following a table expression as an extension to standard SQL syntax. The default implementation of this production is empty. SqlNode TableOverOpt() : { } { { return null; } } Parses dialect-specific keywords immediately following the SELECT keyword. void SqlSelectKeywords(List&lt;SqlLiteral&gt; keywords) : {} { E() } Parses dialect-specific keywords immediately following the INSERT keyword. void SqlInsertKeywords(List&lt;SqlLiteral&gt; keywords) : {} { E() } Parse FloorCeil function parameters SqlNode FloorCeilOptions(Span s, boolean floorFlag) : { SqlNode node; } { node = StandardFloorCeilOptions(s, floorFlag) { return node; } } This file contains the heart of a parser for SQL SELECT statements. code can be shared between various parsers (for example, a DDL parser and a DML parser) but is not a standalone JavaCC file. You need to prepend a parser declaration (such as that in Parser.jj). Epsilon JAVACODE void E() {} JAVACODE List startList(Object o) { List list = new ArrayList(); list.add(o); return list; } NOTE jvs 6-Feb-2004: The straightforward way to implement the SQL grammar is to keep query expressions (SELECT, UNION, etc) separate from row expressions (+, LIKE, etc). However, this is not possible with an LL(k) parser, because both kinds of expressions allow parenthesization, so no fixed amount of left context is ever good enough. A sub-query can be a leaf in a row expression, and can include operators like UNION, so it's not even possible to use a syntactic lookahead rule like &quot;look past an indefinite number of parentheses until you see SELECT, VALUES, or TABLE&quot; (since at that point we still don't know whether we're parsing a sub-query like ((select ...) + x) vs. (select ... union select ...). The somewhat messy solution is to unify the two kinds of expression, and to enforce syntax rules using parameterized context. This is the purpose of the ExprContext parameter. It is passed to most expression productions, which check the expressions encountered against the context for correctness. When a query element like SELECT is encountered, the production calls checkQueryExpression, which will throw an exception if a row expression was expected instead. When a row expression like IN is encountered, the production calls checkNonQueryExpression instead. It is very important to understand how this works when modifying the grammar. The commingling of expressions results in some bogus ambiguities which are resolved with LOOKAHEAD hints. The worst example is comma. SQL allows both (WHERE x IN (1,2)) and (WHERE x IN (select ...)). This means when we parse the right-hand-side of an IN, we have to allow any kind of expression inside the parentheses. Now consider the expression &quot;WHERE x IN(SELECT a FROM b GROUP BY c,d)&quot;. When the parser gets to &quot;c,d&quot; it doesn't know whether the comma indicates the end of the GROUP BY or the end of one item in an IN list. Luckily, we know that select and comma-list are mutually exclusive within IN, so we use maximal munch for the GROUP BY comma. However, this usage of hints could easily mask unintended ambiguities resulting from future changes to the grammar, making it very brittle. JAVACODE protected SqlParserPos getPos() { return new SqlParserPos( token.beginLine, token.beginColumn, token.endLine, token.endColumn); } Starts a span at the current position. JAVACODE Span span() { return Span.of(getPos()); } JAVACODE void checkQueryExpression(ExprContext exprContext) { switch (exprContext) { case ACCEPT_NON_QUERY: case ACCEPT_SUB_QUERY: case ACCEPT_CURSOR: throw SqlUtil.newContextException(getPos(), RESOURCE.illegalQueryExpression()); } } JAVACODE void checkNonQueryExpression(ExprContext exprContext) { switch (exprContext) { case ACCEPT_QUERY: throw SqlUtil.newContextException(getPos(), RESOURCE.illegalNonQueryExpression()); } } Converts a ParseException (local to this particular instantiation of the parser) into a SqlParseException (common to all parsers). JAVACODE SqlParseException convertException(Throwable ex) { if (ex instanceof SqlParseException) { return (SqlParseException) ex; } SqlParserPos pos = null; int[][] expectedTokenSequences = null; String[] tokenImage = null; if (ex instanceof ParseException) { ParseException pex = (ParseException) ex; expectedTokenSequences = pex.expectedTokenSequences; tokenImage = pex.tokenImage; if (pex.currentToken != null) { final Token token = pex.currentToken.next; Checks token.image.equals(&quot;1&quot;) to avoid recursive call. The SqlAbstractParserImplMetadataImpl constructor uses constant &quot;1&quot; to throw intentionally to collect the expected tokens. if (!token.image.equals(&quot;1&quot;) &amp;&amp; getMetadata().isKeyword(token.image) &amp;&amp; SqlParserUtil.allowsIdentifier(tokenImage, expectedTokenSequences)) { If the next token is a keyword, reformat the error message as: Incorrect syntax near the keyword '{keyword}' at line {line_number}, column {column_number}. final String expecting = ex.getMessage() .substring(ex.getMessage().indexOf(&quot;Was expecting&quot;)); final String errorMsg = String.format(&quot;Incorrect syntax near the keyword '%s' &quot; + &quot;at line %d, column %d.\n%s&quot;, token.image, token.beginLine, token.beginColumn, expecting); Replace the ParseException with explicit error message. ex = new ParseException(errorMsg); } pos = new SqlParserPos( token.beginLine, token.beginColumn, token.endLine, token.endColumn); } } else if (ex instanceof TokenMgrError) { TokenMgrError tme = (TokenMgrError) ex; expectedTokenSequences = null; tokenImage = null; Example: Lexical error at line 3, column 24. Encountered &quot;&quot; after &quot;a&quot;. final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile( &quot;(?s)Lexical error at line ([0-9]+), column ([0-9]+).&quot;); java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage()); if (matcher.matches()) { int line = Integer.parseInt(matcher.group(1)); int column = Integer.parseInt(matcher.group(2)); pos = new SqlParserPos(line, column, line, column); } } else if (ex instanceof CalciteContextException) { CalciteContextException is the standard wrapper for exceptions produced by the validator, but in the parser, the standard is SqlParseException; so, strip it away. In case you were wondering, the CalciteContextException appears because the parser occasionally calls into validator-style code such as SqlSpecialOperator.reduceExpr. CalciteContextException ece = (CalciteContextException) ex; pos = new SqlParserPos( ece.getPosLine(), ece.getPosColumn(), ece.getEndPosLine(), ece.getEndPosColumn()); ex = ece.getCause(); } return new SqlParseException( ex.getMessage(), pos, expectedTokenSequences, tokenImage, ex); } Removes or transforms misleading information from a parse exception. @param e dirty excn @return clean excn JAVACODE ParseException cleanupParseException(ParseException ex) { if (ex.expectedTokenSequences == null) { return ex; } int iIdentifier = Arrays.asList(ex.tokenImage).indexOf(&quot;&lt;IDENTIFIER&gt;&quot;); Find all sequences in the error which contain identifier. For example, {&lt;IDENTIFIER&gt;} {A} {B, C} {D, &lt;IDENTIFIER&gt;} {D, A} {D, B} would yield {} {D} boolean id = false; final List&lt;int[]&gt; prefixList = new ArrayList&lt;int[]&gt;(); for (int i = 0; i &lt; ex.expectedTokenSequences.length; ++i) { int[] seq = ex.expectedTokenSequences[i]; int j = seq.length - 1; int i1 = seq[j]; if (i1 == iIdentifier) { int[] prefix = new int[j]; System.arraycopy(seq, 0, prefix, 0, j); prefixList.add(prefix); } } if (prefixList.isEmpty()) { return ex; } int[][] prefixes = (int[][]) prefixList.toArray(new int[prefixList.size()][]); Since &lt;IDENTIFIER&gt; was one of the possible productions, we know that the parser will also have included all of the non-reserved keywords (which are treated as identifiers in non-keyword contexts). So, now we need to clean those out, since they're totally irrelevant. final List&lt;int[]&gt; list = new ArrayList&lt;int[]&gt;(); Metadata metadata = getMetadata(); for (int i = 0; i &lt; ex.expectedTokenSequences.length; ++i) { int [] seq = ex.expectedTokenSequences[i]; String tokenImage = ex.tokenImage[seq[seq.length - 1]]; String token = SqlParserUtil.getTokenVal(tokenImage); if (token == null || !metadata.isNonReservedKeyword(token)) { list.add(seq); continue; } boolean match = matchesPrefix(seq, prefixes); if (!match) { list.add(seq); } } ex.expectedTokenSequences = (int [][]) list.toArray(new int [list.size()][]); return ex; } JAVACODE boolean matchesPrefix(int[] seq, int[][] prefixes) { nextPrefix: for (int[] prefix : prefixes) { if (seq.length == prefix.length + 1) { for (int k = 0; k &lt; prefix.length; k++) { if (prefix[k] != seq[k]) { continue nextPrefix; } } return true; } } return false; } Syntactical Descriptions Parses either a row expression or a query expression with an optional ORDER BY. &lt;p&gt;Postgres syntax for limit: &lt;blockquote&gt;&lt;pre&gt; [ LIMIT { count | ALL } ] [ OFFSET start ]&lt;pre&gt; &lt;blockquote&gt; &lt;p&gt;MySQL syntax for limit: &lt;blockquote&gt;&lt;pre&gt; [ LIMIT { count | start, count } ]&lt;pre&gt; &lt;blockquote&gt; &lt;p&gt;SQL:2008 syntax for limit: &lt;blockquote&gt;&lt;pre&gt; [ OFFSET start { ROW | ROWS } ] [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]&lt;pre&gt; &lt;blockquote&gt; SqlNode OrderedQueryOrExpr(ExprContext exprContext) : { SqlNode e; SqlNodeList orderBy = null; SqlNode start = null; SqlNode count = null; } { ( e = QueryOrExpr(exprContext) ) [ use the syntactic type of the expression we just parsed to decide whether ORDER BY makes sense orderBy = OrderBy(e.isA(SqlKind.QUERY)) ] [ Postgres-style syntax. &quot;LIMIT ... OFFSET ...&quot; &lt;LIMIT&gt; ( MySQL-style syntax. &quot;LIMIT start, count&quot; LOOKAHEAD(2) start = UnsignedNumericLiteralOrParam() &lt;COMMA&gt; count = UnsignedNumericLiteralOrParam() { if (!this.conformance.isLimitStartCountAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.limitStartCountNotAllowed()); } } | count = UnsignedNumericLiteralOrParam() | &lt;ALL&gt; ) ] [ ROW or ROWS is required in SQL:2008 but we make it optional because it is not present in Postgres-style syntax. If you specify both LIMIT start and OFFSET, OFFSET wins. &lt;OFFSET&gt; start = UnsignedNumericLiteralOrParam() [ &lt;ROW&gt; | &lt;ROWS&gt; ] ] [ SQL:2008-style syntax. &quot;OFFSET ... FETCH ...&quot;. If you specify both LIMIT and FETCH, FETCH wins. &lt;FETCH&gt; ( &lt;FIRST&gt; | &lt;NEXT&gt; ) count = UnsignedNumericLiteralOrParam() ( &lt;ROW&gt; | &lt;ROWS&gt; ) &lt;ONLY&gt; ] { if (orderBy != null || start != null || count != null) { if (orderBy == null) { orderBy = SqlNodeList.EMPTY; } e = new SqlOrderBy(getPos(), e, orderBy, start, count); } return e; } } Parses a leaf in a query expression (SELECT, VALUES or TABLE). SqlNode LeafQuery(ExprContext exprContext) : { SqlNode e; } { { ensure a query is legal in this context checkQueryExpression(exprContext); } e = SqlSelect() { return e; } | e = TableConstructor() { return e; } | e = ExplicitTable(getPos()) { return e; } } Parses a parenthesized query or single row expression. SqlNode ParenthesizedExpression(ExprContext exprContext) : { SqlNode e; } { &lt;LPAREN&gt; { we've now seen left paren, so queries inside should be allowed as sub-queries switch (exprContext) { case ACCEPT_SUB_QUERY: exprContext = ExprContext.ACCEPT_NONCURSOR; break; case ACCEPT_CURSOR: exprContext = ExprContext.ACCEPT_ALL; break; } } e = OrderedQueryOrExpr(exprContext) &lt;RPAREN&gt; { return e; } } Parses a parenthesized query or comma-list of row expressions. &lt;p&gt;REVIEW jvs 8-Feb-2004: There's a small hole in this production. It can be used to construct something like &lt;blockquote&gt;&lt;pre&gt; WHERE x IN (select count() from t where c=d,5)&lt;pre&gt; &lt;blockquote&gt; &lt;p&gt;which should be illegal. The above is interpreted as equivalent to &lt;blockquote&gt;&lt;pre&gt; WHERE x IN ((select count() from t where c=d),5)&lt;pre&gt; &lt;blockquote&gt; &lt;p&gt;which is a legal use of a sub-query. The only way to fix the hole is to be able to remember whether a subexpression was parenthesized or not, which means preserving parentheses in the SqlNode tree. This is probably desirable anyway for use in purely syntactic parsing applications (e.g. SQL pretty-printer). However, if this is done, it's important to also make isA() on the paren node call down to its operand so that we can always correctly discriminate a query from a row expression. SqlNodeList ParenthesizedQueryOrCommaList( ExprContext exprContext) : { SqlNode e; List&lt;SqlNode&gt; list; ExprContext firstExprContext = exprContext; final Span s; } { &lt;LPAREN&gt; { we've now seen left paren, so a query by itself should be interpreted as a sub-query s = span(); switch (exprContext) { case ACCEPT_SUB_QUERY: firstExprContext = ExprContext.ACCEPT_NONCURSOR; break; case ACCEPT_CURSOR: firstExprContext = ExprContext.ACCEPT_ALL; break; } } e = OrderedQueryOrExpr(firstExprContext) { list = startList(e); } ( &lt;COMMA&gt; { a comma-list can't appear where only a query is expected checkNonQueryExpression(exprContext); } e = Expression(exprContext) { list.add(e); } ) &lt;RPAREN&gt; { return new SqlNodeList(list, s.end(this)); } } As ParenthesizedQueryOrCommaList, but allows DEFAULT in place of any of the expressions. For example, {@code (x, DEFAULT, null, DEFAULT)}. SqlNodeList ParenthesizedQueryOrCommaListWithDefault( ExprContext exprContext) : { SqlNode e; List&lt;SqlNode&gt; list; ExprContext firstExprContext = exprContext; final Span s; } { &lt;LPAREN&gt; { we've now seen left paren, so a query by itself should be interpreted as a sub-query s = span(); switch (exprContext) { case ACCEPT_SUB_QUERY: firstExprContext = ExprContext.ACCEPT_NONCURSOR; break; case ACCEPT_CURSOR: firstExprContext = ExprContext.ACCEPT_ALL; break; } } ( e = OrderedQueryOrExpr(firstExprContext) | e = Default() ) { list = startList(e); } ( &lt;COMMA&gt; { a comma-list can't appear where only a query is expected checkNonQueryExpression(exprContext); } ( e = Expression(exprContext) | e = Default() ) { list.add(e); } ) &lt;RPAREN&gt; { return new SqlNodeList(list, s.end(this)); } } Parses function parameter lists. If the list starts with DISTINCT or ALL, it is discarded. List UnquantifiedFunctionParameterList( ExprContext exprContext) : { final List args; } { args = FunctionParameterList(exprContext) { final SqlLiteral quantifier = (SqlLiteral) args.get(0); args.remove(0); remove DISTINCT or ALL, if present return args; } } Parses function parameter lists including DISTINCT keyword recognition, DEFAULT, and named argument assignment. List FunctionParameterList( ExprContext exprContext) : { SqlNode e = null; List list = new ArrayList(); } { &lt;LPAREN&gt; [ &lt;DISTINCT&gt; { e = SqlSelectKeyword.DISTINCT.symbol(getPos()); } | &lt;ALL&gt; { e = SqlSelectKeyword.ALL.symbol(getPos()); } ] { list.add(e); } Arg0(list, exprContext) ( &lt;COMMA&gt; { a comma-list can't appear where only a query is expected checkNonQueryExpression(exprContext); } Arg(list, exprContext) ) &lt;RPAREN&gt; { return list; } } void Arg0(List list, ExprContext exprContext) : { SqlIdentifier name = null; SqlNode e = null; final ExprContext firstExprContext; { we've now seen left paren, so queries inside should be allowed as sub-queries switch (exprContext) { case ACCEPT_SUB_QUERY: firstExprContext = ExprContext.ACCEPT_NONCURSOR; break; case ACCEPT_CURSOR: firstExprContext = ExprContext.ACCEPT_ALL; break; default: firstExprContext = exprContext; break; } } } { [ LOOKAHEAD(2) name = SimpleIdentifier() &lt;NAMED_ARGUMENT_ASSIGNMENT&gt; ] ( e = Default() | e = OrderedQueryOrExpr(firstExprContext) ) { if (e != null) { if (name != null) { e = SqlStdOperatorTable.ARGUMENT_ASSIGNMENT.createCall( Span.of(name, e).pos(), e, name); } list.add(e); } } } void Arg(List list, ExprContext exprContext) : { SqlIdentifier name = null; SqlNode e = null; } { [ LOOKAHEAD(2) name = SimpleIdentifier() &lt;NAMED_ARGUMENT_ASSIGNMENT&gt; ] ( e = Default() | e = Expression(exprContext) ) { if (e != null) { if (name != null) { e = SqlStdOperatorTable.ARGUMENT_ASSIGNMENT.createCall( Span.of(name, e).pos(), e, name); } list.add(e); } } } SqlNode Default() : {} { &lt;DEFAULT_&gt; { return SqlStdOperatorTable.DEFAULT.createCall(getPos()); } } Parses a query (SELECT, UNION, INTERSECT, EXCEPT, VALUES, TABLE) followed by the end-of-file symbol. SqlNode SqlQueryEof() : { SqlNode query; } { query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) &lt;EOF&gt; { return query; } } Parses a list of SQL statements separated by semicolon. The semicolon is required between statements, but is optional at the end. SqlNodeList SqlStmtList() : { final List&lt;SqlNode&gt; stmtList = new ArrayList&lt;SqlNode&gt;(); SqlNode stmt; } { stmt = SqlStmt() { stmtList.add(stmt); } ( &lt;SEMICOLON&gt; [ stmt = SqlStmt() { stmtList.add(stmt); } ] ) &lt;EOF&gt; { return new SqlNodeList(stmtList, Span.of(stmtList).pos()); } } Parses an SQL statement. SqlNode SqlStmt() : { SqlNode stmt; } { ( &lt;-- Add methods to parse additional statements here --&gt; &lt;list (parser.statementParserMethods!default.parser.statementParserMethods) as method&gt; LOOKAHEAD(2) stmt = {method} | &lt;list&gt; stmt = SqlSetOption(Span.of(), null) | stmt = SqlAlter() | &lt;if (parser.createStatementParserMethods!default.parser.createStatementParserMethods)?size != 0&gt; stmt = SqlCreate() | &lt;if&gt; &lt;if (parser.dropStatementParserMethods!default.parser.dropStatementParserMethods)?size != 0&gt; stmt = SqlDrop() | &lt;if&gt; stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) | stmt = SqlExplain() | stmt = SqlDescribe() | stmt = SqlInsert() | stmt = SqlDelete() | stmt = SqlUpdate() | stmt = SqlMerge() | stmt = SqlProcedureCall() ) { return stmt; } } Parses an SQL statement followed by the end-of-file symbol. SqlNode SqlStmtEof() : { SqlNode stmt; } { stmt = SqlStmt() &lt;EOF&gt; { return stmt; } } &lt;-- Add implementations of additional parser statement calls here --&gt; &lt;list (parser.implementationFiles!default.parser.implementationFiles) as file&gt; &lt;include &quot;@includes&quot;+file &gt; &lt;list&gt; SqlNodeList ParenthesizedKeyValueOptionCommaList() : { final Span s; final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); } { { s = span(); } &lt;LPAREN&gt; KeyValueOption(list) ( &lt;COMMA&gt; KeyValueOption(list) ) &lt;RPAREN&gt; { return new SqlNodeList(list, s.end(this)); } } Parses an option with format key=val whose key is a simple identifier or string literal and value is a string literal. void KeyValueOption(List&lt;SqlNode&gt; list) : { final SqlNode key; final SqlNode value; } { ( key = SimpleIdentifier() | key = StringLiteral() ) &lt;EQ&gt; value = StringLiteral() { list.add(key); list.add(value); } } Parses an option value, it's either a string or a numeric. SqlNode OptionValue() : { final SqlNode value; } { ( value = NumericLiteral() | value = StringLiteral() ) { return value; } } Parses a literal list separated by comma. The literal is either a string or a numeric. SqlNodeList ParenthesizedLiteralOptionCommaList() : { final Span s; final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); SqlNode optionVal; } { { s = span(); } &lt;LPAREN&gt; optionVal = OptionValue() { list.add(optionVal); } ( &lt;COMMA&gt; optionVal = OptionValue() { list.add(optionVal); } ) &lt;RPAREN&gt; { return new SqlNodeList(list, s.end(this)); } } void CommaSeparatedSqlHints(List&lt;SqlNode&gt; hints) : { SqlIdentifier hintName; SqlNodeList hintOptions; SqlNode optionVal; SqlHint.HintOptionFormat optionFormat; } { hintName = SimpleIdentifier() ( LOOKAHEAD(5) hintOptions = ParenthesizedKeyValueOptionCommaList() { optionFormat = SqlHint.HintOptionFormat.KV_LIST; } | LOOKAHEAD(3) hintOptions = ParenthesizedSimpleIdentifierList() { optionFormat = SqlHint.HintOptionFormat.ID_LIST; } | LOOKAHEAD(3) hintOptions = ParenthesizedLiteralOptionCommaList() { optionFormat = SqlHint.HintOptionFormat.LITERAL_LIST; } | LOOKAHEAD(2) [&lt;LPAREN&gt; &lt;RPAREN&gt;] { hintOptions = SqlNodeList.EMPTY; optionFormat = SqlHint.HintOptionFormat.EMPTY; } ) { hints.add(new SqlHint(Span.of(hintOptions).end(this), hintName, hintOptions, optionFormat)); } ( &lt;COMMA&gt; hintName = SimpleIdentifier() ( LOOKAHEAD(5) hintOptions = ParenthesizedKeyValueOptionCommaList() { optionFormat = SqlHint.HintOptionFormat.KV_LIST; } | LOOKAHEAD(3) hintOptions = ParenthesizedSimpleIdentifierList() { optionFormat = SqlHint.HintOptionFormat.ID_LIST; } | LOOKAHEAD(3) hintOptions = ParenthesizedLiteralOptionCommaList() { optionFormat = SqlHint.HintOptionFormat.LITERAL_LIST; } | LOOKAHEAD(2) [&lt;LPAREN&gt; &lt;RPAREN&gt;] { hintOptions = SqlNodeList.EMPTY; optionFormat = SqlHint.HintOptionFormat.EMPTY; } ) { hints.add(new SqlHint(Span.of(hintOptions).end(this), hintName, hintOptions, optionFormat)); } ) } Parses a table reference with optional hints. SqlNode TableRefWithHintsOpt() : { SqlNode tableRef; SqlNodeList hintList; final List&lt;SqlNode&gt; hints = new ArrayList&lt;SqlNode&gt;(); final Span s; } { { s = span(); } tableRef = CompoundTableIdentifier() [ LOOKAHEAD(2) &lt;HINT_BEG&gt; CommaSeparatedSqlHints(hints) &lt;COMMENT_END&gt; { hintList = new SqlNodeList(hints, s.addAll(hints).end(this)); tableRef = new SqlTableRef(Span.of(tableRef, hintList).pos(), (SqlIdentifier) tableRef, hintList); } ] { return tableRef; } } Parses a leaf SELECT expression without ORDER BY. SqlSelect SqlSelect() : { final List&lt;SqlLiteral&gt; keywords = new ArrayList&lt;SqlLiteral&gt;(); final SqlNodeList keywordList; List&lt;SqlNode&gt; selectList; final SqlNode fromClause; final SqlNode where; final SqlNodeList groupBy; final SqlNode having; final SqlNodeList windowDecls; final List&lt;SqlNode&gt; hints = new ArrayList&lt;SqlNode&gt;(); final Span s; } { &lt;SELECT&gt; { s = span(); } [ &lt;HINT_BEG&gt; CommaSeparatedSqlHints(hints) &lt;COMMENT_END&gt; ] SqlSelectKeywords(keywords) ( &lt;STREAM&gt; { keywords.add(SqlSelectKeyword.STREAM.symbol(getPos())); } )? ( &lt;DISTINCT&gt; { keywords.add(SqlSelectKeyword.DISTINCT.symbol(getPos())); } | &lt;ALL&gt; { keywords.add(SqlSelectKeyword.ALL.symbol(getPos())); } )? { keywordList = new SqlNodeList(keywords, s.addAll(keywords).pos()); } selectList = SelectList() ( &lt;FROM&gt; fromClause = FromClause() where = WhereOpt() groupBy = GroupByOpt() having = HavingOpt() windowDecls = WindowOpt() | E() { fromClause = null; where = null; groupBy = null; having = null; windowDecls = null; } ) { return new SqlSelect(s.end(this), keywordList, new SqlNodeList(selectList, Span.of(selectList).pos()), fromClause, where, groupBy, having, windowDecls, null, null, null, new SqlNodeList(hints, getPos())); } } Abstract production: void SqlSelectKeywords(List keywords) Parses dialect-specific keywords immediately following the SELECT keyword. Parses an EXPLAIN PLAN statement. SqlNode SqlExplain() : { SqlNode stmt; SqlExplainLevel detailLevel = SqlExplainLevel.EXPPLAN_ATTRIBUTES; SqlExplain.Depth depth; final SqlExplainFormat format; } { &lt;EXPLAIN&gt; &lt;PLAN&gt; [ detailLevel = ExplainDetailLevel() ] depth = ExplainDepth() ( LOOKAHEAD(2) &lt;AS&gt; &lt;XML&gt; { format = SqlExplainFormat.XML; } | &lt;AS&gt; &lt;JSON&gt; { format = SqlExplainFormat.JSON; } | { format = SqlExplainFormat.TEXT; } ) &lt;FOR&gt; stmt = SqlQueryOrDml() { return new SqlExplain(getPos(), stmt, detailLevel.symbol(SqlParserPos.ZERO), depth.symbol(SqlParserPos.ZERO), format.symbol(SqlParserPos.ZERO), nDynamicParams); } } Parses a query (SELECT or VALUES) or DML statement (INSERT, UPDATE, DELETE, MERGE). SqlNode SqlQueryOrDml() : { SqlNode stmt; } { ( stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) | stmt = SqlInsert() | stmt = SqlDelete() | stmt = SqlUpdate() | stmt = SqlMerge() ) { return stmt; } } Parses WITH TYPE | WITH IMPLEMENTATION | WITHOUT IMPLEMENTATION modifier for EXPLAIN PLAN. SqlExplain.Depth ExplainDepth() : { } { ( LOOKAHEAD(2) &lt;WITH&gt; &lt;TYPE_Q&gt; { return SqlExplain.Depth.TYPE; } | &lt;WITH&gt; &lt;IMPLEMENTATION&gt; { return SqlExplain.Depth.PHYSICAL; } | &lt;WITHOUT&gt; &lt;IMPLEMENTATION&gt; { return SqlExplain.Depth.LOGICAL; } | { return SqlExplain.Depth.PHYSICAL; } ) } Parses INCLUDING ALL ATTRIBUTES modifier for EXPLAIN PLAN. SqlExplainLevel ExplainDetailLevel() : { SqlExplainLevel level = SqlExplainLevel.EXPPLAN_ATTRIBUTES; } { ( &lt;EXCLUDING&gt; &lt;ATTRIBUTES&gt; { level = SqlExplainLevel.NO_ATTRIBUTES; } | &lt;INCLUDING&gt; [ &lt;ALL&gt; { level = SqlExplainLevel.ALL_ATTRIBUTES; } ] &lt;ATTRIBUTES&gt; { } ) { return level; } } Parses a DESCRIBE statement. SqlNode SqlDescribe() : { final Span s; final SqlIdentifier table; final SqlIdentifier column; final SqlIdentifier id; final SqlNode stmt; } { &lt;DESCRIBE&gt; { s = span(); } ( LOOKAHEAD(2) (&lt;DATABASE&gt; | &lt;CATALOG&gt; | &lt;SCHEMA&gt;) id = CompoundIdentifier() { DESCRIBE DATABASE and DESCRIBE CATALOG currently do the same as DESCRIBE SCHEMA but should be different. See [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT return new SqlDescribeSchema(s.end(id), id); } | Use syntactic lookahead to determine whether a table name is coming. We do not allow SimpleIdentifier() because that includes &lt;STATEMENT&gt;. LOOKAHEAD( &lt;TABLE&gt; | &lt;IDENTIFIER&gt; | &lt;HYPHENATED_IDENTIFIER&gt; | &lt;QUOTED_IDENTIFIER&gt; | &lt;BACK_QUOTED_IDENTIFIER&gt; | &lt;BRACKET_QUOTED_IDENTIFIER&gt; ) (&lt;TABLE&gt;)? table = CompoundIdentifier() ( column = SimpleIdentifier() | E() { column = null; } ) { return new SqlDescribeTable(s.add(table).addIf(column).pos(), table, column); } | (LOOKAHEAD(1) &lt;STATEMENT&gt;)? stmt = SqlQueryOrDml() { DESCRIBE STATEMENT currently does the same as EXPLAIN. See [CALCITE-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT final SqlExplainLevel detailLevel = SqlExplainLevel.EXPPLAN_ATTRIBUTES; final SqlExplain.Depth depth = SqlExplain.Depth.PHYSICAL; final SqlExplainFormat format = SqlExplainFormat.TEXT; return new SqlExplain(s.end(stmt), stmt, detailLevel.symbol(SqlParserPos.ZERO), depth.symbol(SqlParserPos.ZERO), format.symbol(SqlParserPos.ZERO), nDynamicParams); } ) } Parses a CALL statement. SqlNode SqlProcedureCall() : { final Span s; SqlNode routineCall; } { &lt;CALL&gt; { s = span(); } routineCall = NamedRoutineCall( SqlFunctionCategory.USER_DEFINED_PROCEDURE, ExprContext.ACCEPT_SUB_QUERY) { return SqlStdOperatorTable.PROCEDURE_CALL.createCall( s.end(routineCall), routineCall); } } SqlNode NamedRoutineCall( SqlFunctionCategory routineType, ExprContext exprContext) : { SqlIdentifier name; final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); final Span s; } { name = CompoundIdentifier() { s = span(); } &lt;LPAREN&gt; [ Arg0(list, exprContext) ( &lt;COMMA&gt; { a comma-list can't appear where only a query is expected checkNonQueryExpression(exprContext); } Arg(list, exprContext) ) ] &lt;RPAREN&gt; { return createCall(name, s.end(this), routineType, null, list); } } Parses an INSERT statement. SqlNode SqlInsert() : { final List&lt;SqlLiteral&gt; keywords = new ArrayList&lt;SqlLiteral&gt;(); final SqlNodeList keywordList; SqlNode table; SqlNodeList extendList = null; SqlNode source; SqlNodeList columnList = null; final Span s; } { ( &lt;INSERT&gt; | &lt;UPSERT&gt; { keywords.add(SqlInsertKeyword.UPSERT.symbol(getPos())); } ) { s = span(); } SqlInsertKeywords(keywords) { keywordList = new SqlNodeList(keywords, s.addAll(keywords).pos()); } &lt;INTO&gt; table = TableRefWithHintsOpt() [ LOOKAHEAD(5) [ &lt;EXTEND&gt; ] extendList = ExtendList() { table = extend(table, extendList); } ] [ LOOKAHEAD(2) { final Pair&lt;SqlNodeList, SqlNodeList&gt; p; } p = ParenthesizedCompoundIdentifierList() { if (p.right.size() &gt; 0) { table = extend(table, p.right); } if (p.left.size() &gt; 0) { columnList = p.left; } } ] source = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) { return new SqlInsert(s.end(source), keywordList, table, source, columnList); } } Abstract production: void SqlInsertKeywords(List keywords) Parses dialect-specific keywords immediately following the INSERT keyword. Parses a DELETE statement. SqlNode SqlDelete() : { SqlNode table; SqlNodeList extendList = null; SqlIdentifier alias = null; final SqlNode condition; final Span s; } { &lt;DELETE&gt; { s = span(); } &lt;FROM&gt; table = TableRefWithHintsOpt() [ [ &lt;EXTEND&gt; ] extendList = ExtendList() { table = extend(table, extendList); } ] [ [ &lt;AS&gt; ] alias = SimpleIdentifier() ] condition = WhereOpt() { return new SqlDelete(s.add(table).addIf(extendList).addIf(alias) .addIf(condition).pos(), table, condition, null, alias); } } Parses an UPDATE statement. SqlNode SqlUpdate() : { SqlNode table; SqlNodeList extendList = null; SqlIdentifier alias = null; SqlNode condition; SqlNodeList sourceExpressionList; SqlNodeList targetColumnList; SqlIdentifier id; SqlNode exp; final Span s; } { &lt;UPDATE&gt; { s = span(); } table = TableRefWithHintsOpt() { targetColumnList = new SqlNodeList(s.pos()); sourceExpressionList = new SqlNodeList(s.pos()); } [ [ &lt;EXTEND&gt; ] extendList = ExtendList() { table = extend(table, extendList); } ] [ [ &lt;AS&gt; ] alias = SimpleIdentifier() ] &lt;SET&gt; id = SimpleIdentifier() { targetColumnList.add(id); } &lt;EQ&gt; exp = Expression(ExprContext.ACCEPT_SUB_QUERY) { TODO: support DEFAULT also sourceExpressionList.add(exp); } ( &lt;COMMA&gt; id = SimpleIdentifier() { targetColumnList.add(id); } &lt;EQ&gt; exp = Expression(ExprContext.ACCEPT_SUB_QUERY) { sourceExpressionList.add(exp); } ) condition = WhereOpt() { return new SqlUpdate(s.addAll(targetColumnList) .addAll(sourceExpressionList).addIf(condition).pos(), table, targetColumnList, sourceExpressionList, condition, null, alias); } } Parses a MERGE statement. SqlNode SqlMerge() : { SqlNode table; SqlNodeList extendList = null; SqlIdentifier alias = null; SqlNode sourceTableRef; SqlNode condition; SqlUpdate updateCall = null; SqlInsert insertCall = null; final Span s; } { &lt;MERGE&gt; { s = span(); } &lt;INTO&gt; table = TableRefWithHintsOpt() [ [ &lt;EXTEND&gt; ] extendList = ExtendList() { table = extend(table, extendList); } ] [ [ &lt;AS&gt; ] alias = SimpleIdentifier() ] &lt;USING&gt; sourceTableRef = TableRef() &lt;ON&gt; condition = Expression(ExprContext.ACCEPT_SUB_QUERY) ( LOOKAHEAD(2) updateCall = WhenMatchedClause(table, alias) [ insertCall = WhenNotMatchedClause(table) ] | insertCall = WhenNotMatchedClause(table) ) { return new SqlMerge(s.addIf(updateCall).addIf(insertCall).pos(), table, condition, sourceTableRef, updateCall, insertCall, null, alias); } } SqlUpdate WhenMatchedClause(SqlNode table, SqlIdentifier alias) : { SqlIdentifier id; final Span s; final SqlNodeList updateColumnList = new SqlNodeList(SqlParserPos.ZERO); SqlNode exp; final SqlNodeList updateExprList = new SqlNodeList(SqlParserPos.ZERO); } { &lt;WHEN&gt; { s = span(); } &lt;MATCHED&gt; &lt;THEN&gt; &lt;UPDATE&gt; &lt;SET&gt; id = CompoundIdentifier() { updateColumnList.add(id); } &lt;EQ&gt; exp = Expression(ExprContext.ACCEPT_SUB_QUERY) { updateExprList.add(exp); } ( &lt;COMMA&gt; id = CompoundIdentifier() { updateColumnList.add(id); } &lt;EQ&gt; exp = Expression(ExprContext.ACCEPT_SUB_QUERY) { updateExprList.add(exp); } ) { return new SqlUpdate(s.addAll(updateExprList).pos(), table, updateColumnList, updateExprList, null, null, alias); } } SqlInsert WhenNotMatchedClause(SqlNode table) : { final Span insertSpan, valuesSpan; final List&lt;SqlLiteral&gt; keywords = new ArrayList&lt;SqlLiteral&gt;(); final SqlNodeList keywordList; SqlNodeList insertColumnList = null; SqlNode rowConstructor; SqlNode insertValues; } { &lt;WHEN&gt; &lt;NOT&gt; &lt;MATCHED&gt; &lt;THEN&gt; &lt;INSERT&gt; { insertSpan = span(); } SqlInsertKeywords(keywords) { keywordList = new SqlNodeList(keywords, insertSpan.end(this)); } [ LOOKAHEAD(2) insertColumnList = ParenthesizedSimpleIdentifierList() ] [ &lt;LPAREN&gt; ] &lt;VALUES&gt; { valuesSpan = span(); } rowConstructor = RowConstructor() [ &lt;RPAREN&gt; ] { TODO zfong 52606: note that extra parentheses are accepted above around the VALUES clause as a hack for unparse, but this is actually invalid SQL; should fix unparse insertValues = SqlStdOperatorTable.VALUES.createCall( valuesSpan.end(this), rowConstructor); return new SqlInsert(insertSpan.end(this), keywordList, table, insertValues, insertColumnList); } } Parses the select list of a SELECT statement. List&lt;SqlNode&gt; SelectList() : { final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); SqlNode item; } { item = SelectItem() { list.add(item); } ( &lt;COMMA&gt; item = SelectItem() { list.add(item); } ) { return list; } } Parses one item in a select list. SqlNode SelectItem() : { SqlNode e; final SqlIdentifier id; } { e = SelectExpression() [ [ &lt;AS&gt; ] ( id = SimpleIdentifier() | Mute the warning about ambiguity between alias and continued string literal. LOOKAHEAD(1) id = SimpleIdentifierFromStringLiteral() ) { e = SqlStdOperatorTable.AS.createCall(span().end(e), e, id); } ] { return e; } } Parses one unaliased expression in a select list. SqlNode SelectExpression() : { SqlNode e; } { &lt;STAR&gt; { return SqlIdentifier.star(getPos()); } | e = Expression(ExprContext.ACCEPT_SUB_QUERY) { return e; } } SqlLiteral Natural() : { } { &lt;NATURAL&gt; { return SqlLiteral.createBoolean(true, getPos()); } | { return SqlLiteral.createBoolean(false, getPos()); } } SqlLiteral JoinType() : { JoinType joinType; } { ( LOOKAHEAD(3) required for &quot;LEFT SEMI JOIN&quot; in Babel &lt;list (parser.joinTypes!default.parser.joinTypes) as method&gt; joinType = {method}() | &lt;list&gt; &lt;JOIN&gt; { joinType = JoinType.INNER; } | &lt;INNER&gt; &lt;JOIN&gt; { joinType = JoinType.INNER; } | &lt;LEFT&gt; [ &lt;OUTER&gt; ] &lt;JOIN&gt; { joinType = JoinType.LEFT; } | &lt;RIGHT&gt; [ &lt;OUTER&gt; ] &lt;JOIN&gt; { joinType = JoinType.RIGHT; } | &lt;FULL&gt; [ &lt;OUTER&gt; ] &lt;JOIN&gt; { joinType = JoinType.FULL; } | &lt;CROSS&gt; &lt;JOIN&gt; { joinType = JoinType.CROSS; } ) { return joinType.symbol(getPos()); } } Matches &quot;LEFT JOIN t ON ...&quot;, &quot;RIGHT JOIN t USING ...&quot;, &quot;JOIN t&quot;. SqlNode JoinTable(SqlNode e) : { SqlNode e2, condition; final SqlLiteral natural, joinType, on, using; SqlNodeList list; } { natural = Natural() joinType = JoinType() e2 = TableRef() ( &lt;ON&gt; { on = JoinConditionType.ON.symbol(getPos()); } condition = Expression(ExprContext.ACCEPT_SUB_QUERY) { return new SqlJoin(joinType.getParserPosition(), e, natural, joinType, e2, on, condition); } | &lt;USING&gt; { using = JoinConditionType.USING.symbol(getPos()); } list = ParenthesizedSimpleIdentifierList() { return new SqlJoin(joinType.getParserPosition(), e, natural, joinType, e2, using, new SqlNodeList(list.getList(), Span.of(using).end(this))); } | { return new SqlJoin(joinType.getParserPosition(), e, natural, joinType, e2, JoinConditionType.NONE.symbol(joinType.getParserPosition()), null); } ) } TODO jvs 15-Nov-2003: SQL standard allows parentheses in the FROM list for building up non-linear join trees (e.g. OUTER JOIN two tables, and then INNER JOIN the result). Also note that aliases on parenthesized FROM expressions &quot;hide&quot; all table names inside the parentheses (without aliases, they're visible). We allow CROSS JOIN to have a join condition, even though that is not valid SQL; the validator will catch it. Parses the FROM clause for a SELECT. &lt;p&gt;FROM is mandatory in standard SQL, optional in dialects such as MySQL, PostgreSQL. The parser allows SELECT without FROM, but the validator fails if conformance is, say, STRICT_2003. SqlNode FromClause() : { SqlNode e, e2, condition; SqlLiteral natural, joinType, joinConditionType; SqlNodeList list; SqlParserPos pos; } { e = TableRef() ( LOOKAHEAD(2) ( Decide whether to read a JOIN clause or a comma, or to quit having seen a single entry FROM clause like 'FROM emps'. See comments elsewhere regarding &lt;COMMA&gt; lookahead. And LOOKAHEAD(3) is needed here rather than a LOOKAHEAD(2). Because currently JavaCC calculates minimum lookahead count incorrectly for choice that contains zero size child. For instance, with the generated code, &quot;LOOKAHEAD(2, Natural(), JoinType())&quot; returns true immediately if it sees a single &quot;&lt;CROSS&gt;&quot; token. Where we expect the lookahead succeeds after &quot;&lt;CROSS&gt; &lt;APPLY&gt;&quot;. For more information about the issue, see https:github.comjavaccjavaccissues86 LOOKAHEAD(3) natural = Natural() joinType = JoinType() e2 = TableRef() ( &lt;ON&gt; { joinConditionType = JoinConditionType.ON.symbol(getPos()); } condition = Expression(ExprContext.ACCEPT_SUB_QUERY) { e = new SqlJoin(joinType.getParserPosition(), e, natural, joinType, e2, joinConditionType, condition); } | &lt;USING&gt; { joinConditionType = JoinConditionType.USING.symbol(getPos()); } list = ParenthesizedSimpleIdentifierList() { e = new SqlJoin(joinType.getParserPosition(), e, natural, joinType, e2, joinConditionType, new SqlNodeList(list.getList(), Span.of(joinConditionType).end(this))); } | { e = new SqlJoin(joinType.getParserPosition(), e, natural, joinType, e2, JoinConditionType.NONE.symbol(joinType.getParserPosition()), null); } ) | NOTE jvs 6-Feb-2004: See comments at top of file for why hint is necessary here. I had to use this special semantic lookahead form to get JavaCC to shut up, which makes me even more uneasy. LOOKAHEAD({true}) &lt;COMMA&gt; { joinType = JoinType.COMMA.symbol(getPos()); } e2 = TableRef() { e = new SqlJoin(joinType.getParserPosition(), e, SqlLiteral.createBoolean(false, joinType.getParserPosition()), joinType, e2, JoinConditionType.NONE.symbol(SqlParserPos.ZERO), null); } | &lt;CROSS&gt; { joinType = JoinType.CROSS.symbol(getPos()); } &lt;APPLY&gt; e2 = TableRef2(true) { if (!this.conformance.isApplyAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.applyNotAllowed()); } e = new SqlJoin(joinType.getParserPosition(), e, SqlLiteral.createBoolean(false, joinType.getParserPosition()), joinType, e2, JoinConditionType.NONE.symbol(SqlParserPos.ZERO), null); } | &lt;OUTER&gt; { joinType = JoinType.LEFT.symbol(getPos()); } &lt;APPLY&gt; e2 = TableRef2(true) { if (!this.conformance.isApplyAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.applyNotAllowed()); } e = new SqlJoin(joinType.getParserPosition(), e, SqlLiteral.createBoolean(false, joinType.getParserPosition()), joinType, e2, JoinConditionType.ON.symbol(SqlParserPos.ZERO), SqlLiteral.createBoolean(true, joinType.getParserPosition())); } ) ) { return e; } } Parses a table reference in a FROM clause, not lateral unless LATERAL is explicitly specified. SqlNode TableRef() : { final SqlNode e; } { e = TableRef2(false) { return e; } } Parses a table reference in a FROM clause. SqlNode TableRef2(boolean lateral) : { SqlNode tableRef; final SqlNode over; final SqlNode snapshot; final SqlNode match; SqlNodeList extendList = null; final SqlIdentifier alias; final Span s, s2; SqlNodeList args; SqlNode sample; boolean isBernoulli; SqlNumericLiteral samplePercentage; boolean isRepeatable = false; int repeatableSeed = 0; SqlNodeList columnAliasList = null; SqlUnnestOperator unnestOp = SqlStdOperatorTable.UNNEST; } { ( LOOKAHEAD(2) tableRef = TableRefWithHintsOpt() [ [ &lt;EXTEND&gt; ] extendList = ExtendList() { tableRef = extend(tableRef, extendList); } ] over = TableOverOpt() { if (over != null) { tableRef = SqlStdOperatorTable.OVER.createCall( getPos(), tableRef, over); } } [ tableRef = Snapshot(tableRef) ] [ tableRef = MatchRecognize(tableRef) ] | LOOKAHEAD(2) [ &lt;LATERAL&gt; { lateral = true; } ] tableRef = ParenthesizedExpression(ExprContext.ACCEPT_QUERY) over = TableOverOpt() { if (over != null) { tableRef = SqlStdOperatorTable.OVER.createCall( getPos(), tableRef, over); } if (lateral) { tableRef = SqlStdOperatorTable.LATERAL.createCall( getPos(), tableRef); } } [ tableRef = MatchRecognize(tableRef) ] | &lt;UNNEST&gt; { s = span(); } args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUB_QUERY) [ &lt;WITH&gt; &lt;ORDINALITY&gt; { unnestOp = SqlStdOperatorTable.UNNEST_WITH_ORDINALITY; } ] { tableRef = unnestOp.createCall(s.end(this), args.toArray()); } | [&lt;LATERAL&gt; { lateral = true; } ] &lt;TABLE&gt; { s = span(); } &lt;LPAREN&gt; tableRef = TableFunctionCall(s.pos()) &lt;RPAREN&gt; { if (lateral) { tableRef = SqlStdOperatorTable.LATERAL.createCall( s.end(this), tableRef); } } | tableRef = ExtendedTableRef() ) [ tableRef = Pivot(tableRef) ] [ [ &lt;AS&gt; ] alias = SimpleIdentifier() [ columnAliasList = ParenthesizedSimpleIdentifierList() ] { if (columnAliasList == null) { tableRef = SqlStdOperatorTable.AS.createCall( Span.of(tableRef).end(this), tableRef, alias); } else { List&lt;SqlNode&gt; idList = new ArrayList&lt;SqlNode&gt;(); idList.add(tableRef); idList.add(alias); idList.addAll(columnAliasList.getList()); tableRef = SqlStdOperatorTable.AS.createCall( Span.of(tableRef).end(this), idList); } } ] [ &lt;TABLESAMPLE&gt; { s2 = span(); } ( &lt;SUBSTITUTE&gt; &lt;LPAREN&gt; sample = StringLiteral() &lt;RPAREN&gt; { String sampleName = SqlLiteral.unchain(sample).getValueAs(String.class); SqlSampleSpec sampleSpec = SqlSampleSpec.createNamed(sampleName); final SqlLiteral sampleLiteral = SqlLiteral.createSample(sampleSpec, s2.end(this)); tableRef = SqlStdOperatorTable.TABLESAMPLE.createCall( s2.add(tableRef).end(this), tableRef, sampleLiteral); } | ( &lt;BERNOULLI&gt; { isBernoulli = true; } | &lt;SYSTEM&gt; { isBernoulli = false; } ) &lt;LPAREN&gt; samplePercentage = UnsignedNumericLiteral() &lt;RPAREN&gt; [ &lt;REPEATABLE&gt; &lt;LPAREN&gt; repeatableSeed = IntLiteral() &lt;RPAREN&gt; { isRepeatable = true; } ] { final BigDecimal ONE_HUNDRED = BigDecimal.valueOf(100L); BigDecimal rate = samplePercentage.bigDecimalValue(); if (rate.compareTo(BigDecimal.ZERO) &lt; 0 || rate.compareTo(ONE_HUNDRED) &gt; 0) { throw SqlUtil.newContextException(getPos(), RESOURCE.invalidSampleSize()); } Treat TABLESAMPLE(0) and TABLESAMPLE(100) as no table sampling at all. Not strictly correct: TABLESAMPLE(0) should produce no output, but it simplifies implementation to know that some amount of sampling will occur. In practice values less than ~1E-43% are treated as 0.0 and values greater than ~99.999997% are treated as 1.0 float fRate = rate.divide(ONE_HUNDRED).floatValue(); if (fRate &gt; 0.0f &amp;&amp; fRate &lt; 1.0f) { SqlSampleSpec tableSampleSpec = isRepeatable ? SqlSampleSpec.createTableSample( isBernoulli, fRate, repeatableSeed) : SqlSampleSpec.createTableSample(isBernoulli, fRate); SqlLiteral tableSampleLiteral = SqlLiteral.createSample(tableSampleSpec, s2.end(this)); tableRef = SqlStdOperatorTable.TABLESAMPLE.createCall( s2.end(this), tableRef, tableSampleLiteral); } } ) ] { return tableRef; } } SqlNodeList ExtendList() : { final Span s; List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); } { &lt;LPAREN&gt; { s = span(); } ColumnType(list) ( &lt;COMMA&gt; ColumnType(list) ) &lt;RPAREN&gt; { return new SqlNodeList(list, s.end(this)); } } void ColumnType(List&lt;SqlNode&gt; list) : { SqlIdentifier name; SqlDataTypeSpec type; boolean nullable = true; } { name = CompoundIdentifier() type = DataType() [ &lt;NOT&gt; &lt;NULL&gt; { nullable = false; } ] { list.add(name); list.add(type.withNullable(nullable, getPos())); } } Parses a compound identifier with optional type. void CompoundIdentifierType(List&lt;SqlNode&gt; list, List&lt;SqlNode&gt; extendList) : { final SqlIdentifier name; SqlDataTypeSpec type = null; boolean nullable = true; } { name = CompoundIdentifier() [ type = DataType() [ &lt;NOT&gt; &lt;NULL&gt; { nullable = false; } ] ] { if (type != null) { if (!this.conformance.allowExtend()) { throw SqlUtil.newContextException(type.getParserPosition(), RESOURCE.extendNotAllowed()); } extendList.add(name); extendList.add(type.withNullable(nullable, getPos())); } list.add(name); } } SqlNode TableFunctionCall(SqlParserPos pos) : { SqlNode call; SqlFunctionCategory funcType = SqlFunctionCategory.USER_DEFINED_TABLE_FUNCTION; } { [ &lt;SPECIFIC&gt; { funcType = SqlFunctionCategory.USER_DEFINED_TABLE_SPECIFIC_FUNCTION; } ] call = NamedRoutineCall(funcType, ExprContext.ACCEPT_CURSOR) { return SqlStdOperatorTable.COLLECTION_TABLE.createCall(pos, call); } } Abstract production: SqlNode ExtendedTableRef() &lt;p&gt;Allows parser to be extended with new types of table references. The default implementation of this production is empty. Abstract production: SqlNode TableOverOpt() Allows an OVER clause following a table expression as an extension to standard SQL syntax. The default implementation of this production is empty. Parses an explicit TABLE t reference. SqlNode ExplicitTable(SqlParserPos pos) : { SqlNode tableRef; } { &lt;TABLE&gt; tableRef = CompoundIdentifier() { return SqlStdOperatorTable.EXPLICIT_TABLE.createCall(pos, tableRef); } } Parses a VALUES leaf query expression. SqlNode TableConstructor() : { final List&lt;SqlNode&gt; rowConstructorList = new ArrayList&lt;SqlNode&gt;(); final Span s; } { &lt;VALUES&gt; { s = span(); } RowConstructorList(rowConstructorList) { return SqlStdOperatorTable.VALUES.createCall( s.end(this), rowConstructorList); } } Parses one or more rows in a VALUES expression. void RowConstructorList(List&lt;SqlNode&gt; list) : { SqlNode rowConstructor; } { rowConstructor = RowConstructor() { list.add(rowConstructor); } ( LOOKAHEAD(2) &lt;COMMA&gt; rowConstructor = RowConstructor() { list.add(rowConstructor); } ) } Parses a row constructor in the context of a VALUES expression. SqlNode RowConstructor() : { SqlNodeList valueList; SqlNode value; final Span s; } { hints are necessary here due to common LPAREN prefixes ( TODO jvs 8-Feb-2004: extra parentheses are accepted here as a hack for unparse, but this is actually invalid SQL; should fix unparse LOOKAHEAD(3) &lt;LPAREN&gt; { s = span(); } &lt;ROW&gt; valueList = ParenthesizedQueryOrCommaListWithDefault(ExprContext.ACCEPT_NONCURSOR) &lt;RPAREN&gt; { s.add(this); } | LOOKAHEAD(3) ( &lt;ROW&gt; { s = span(); } | { s = Span.of(); } ) valueList = ParenthesizedQueryOrCommaListWithDefault(ExprContext.ACCEPT_NONCURSOR) | value = Expression(ExprContext.ACCEPT_NONCURSOR) { NOTE: A bare value here is standard SQL syntax, believe it or not. Taken together with multi-row table constructors, it leads to very easy mistakes if you forget the parentheses on a single-row constructor. This is also the reason for the LOOKAHEAD in RowConstructorList(). It would be so much more reasonable to require parentheses. Sigh. s = Span.of(value); valueList = new SqlNodeList(Collections.singletonList(value), value.getParserPosition()); } ) { REVIEW jvs 8-Feb-2004: Should we discriminate between scalar sub-queries inside of ROW and row sub-queries? The standard does, but the distinction seems to be purely syntactic. return SqlStdOperatorTable.ROW.createCall(s.end(valueList), valueList.toArray()); } } Parses the optional WHERE clause for SELECT, DELETE, and UPDATE. SqlNode WhereOpt() : { SqlNode condition; } { &lt;WHERE&gt; condition = Expression(ExprContext.ACCEPT_SUB_QUERY) { return condition; } | { return null; } } Parses the optional GROUP BY clause for SELECT. SqlNodeList GroupByOpt() : { List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); final Span s; } { &lt;GROUP&gt; { s = span(); } &lt;BY&gt; list = GroupingElementList() { return new SqlNodeList(list, s.addAll(list).pos()); } | { return null; } } List&lt;SqlNode&gt; GroupingElementList() : { List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); SqlNode e; } { e = GroupingElement() { list.add(e); } ( LOOKAHEAD(2) &lt;COMMA&gt; e = GroupingElement() { list.add(e); } ) { return list; } } SqlNode GroupingElement() : { List&lt;SqlNode&gt; list; final SqlNodeList nodes; final SqlNode e; final Span s; } { LOOKAHEAD(2) &lt;GROUPING&gt; { s = span(); } &lt;SETS&gt; &lt;LPAREN&gt; list = GroupingElementList() &lt;RPAREN&gt; { return SqlStdOperatorTable.GROUPING_SETS.createCall(s.end(this), list); } | &lt;ROLLUP&gt; { s = span(); } &lt;LPAREN&gt; nodes = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.ROLLUP.createCall(s.end(this), nodes.getList()); } | &lt;CUBE&gt; { s = span(); } &lt;LPAREN&gt; nodes = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.CUBE.createCall(s.end(this), nodes.getList()); } | LOOKAHEAD(3) &lt;LPAREN&gt; &lt;RPAREN&gt; { return new SqlNodeList(getPos()); } | e = Expression(ExprContext.ACCEPT_SUB_QUERY) { return e; } } Parses a list of expressions separated by commas. SqlNodeList ExpressionCommaList( final Span s, ExprContext exprContext) : { final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); } { ExpressionCommaList2(list, exprContext) { return new SqlNodeList(list, s.addAll(list).pos()); } } Parses a list of expressions separated by commas, appending expressions to a given list. void ExpressionCommaList2(List&lt;SqlNode&gt; list, ExprContext exprContext) : { SqlNode e; } { e = Expression(exprContext) { list.add(e); } ( NOTE jvs 6-Feb-2004: See comments at top of file for why hint is necessary here. LOOKAHEAD(2) &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { list.add(e); } ) } Parses the optional HAVING clause for SELECT. SqlNode HavingOpt() : { SqlNode e; } { &lt;HAVING&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { return e; } | { return null; } } Parses the optional WINDOW clause for SELECT SqlNodeList WindowOpt() : { SqlIdentifier id; SqlWindow e; List&lt;SqlNode&gt; list; final Span s; } { &lt;WINDOW&gt; { s = span(); } id = SimpleIdentifier() &lt;AS&gt; e = WindowSpecification() { e.setDeclName(id); list = startList(e); } ( NOTE jhyde 22-Oct-2004: See comments at top of file for why hint is necessary here. LOOKAHEAD(2) &lt;COMMA&gt; id = SimpleIdentifier() &lt;AS&gt; e = WindowSpecification() { e.setDeclName(id); list.add(e); } ) { return new SqlNodeList(list, s.addAll(list).pos()); } | { return null; } } Parses a window specification. SqlWindow WindowSpecification() : { SqlIdentifier id; List list; SqlNodeList partitionList; SqlNodeList orderList; SqlLiteral isRows = SqlLiteral.createBoolean(false, SqlParserPos.ZERO); SqlNode lowerBound = null, upperBound = null; SqlParserPos startPos; final Span s, s1, s2; SqlLiteral allowPartial = null; } { &lt;LPAREN&gt; { s = span(); } ( id = SimpleIdentifier() | { id = null; } ) ( &lt;PARTITION&gt; { s1 = span(); } &lt;BY&gt; partitionList = ExpressionCommaList(s1, ExprContext.ACCEPT_NON_QUERY) | { partitionList = SqlNodeList.EMPTY; } ) ( orderList = OrderBy(true) | { orderList = SqlNodeList.EMPTY; } ) [ ( &lt;ROWS&gt; { isRows = SqlLiteral.createBoolean(true, getPos()); } | &lt;RANGE&gt; { isRows = SqlLiteral.createBoolean(false, getPos()); } ) ( &lt;BETWEEN&gt; lowerBound = WindowRange() &lt;AND&gt; upperBound = WindowRange() | lowerBound = WindowRange() ) ] [ &lt;ALLOW&gt; { s2 = span(); } &lt;PARTIAL&gt; { allowPartial = SqlLiteral.createBoolean(true, s2.end(this)); } | &lt;DISALLOW&gt; { s2 = span(); } &lt;PARTIAL&gt; { allowPartial = SqlLiteral.createBoolean(false, s2.end(this)); } ] &lt;RPAREN&gt; { return SqlWindow.create( null, id, partitionList, orderList, isRows, lowerBound, upperBound, allowPartial, s.end(this)); } } SqlNode WindowRange() : { final SqlNode e; final Span s; } { LOOKAHEAD(2) &lt;CURRENT&gt; { s = span(); } &lt;ROW&gt; { return SqlWindow.createCurrentRow(s.end(this)); } | LOOKAHEAD(2) &lt;UNBOUNDED&gt; { s = span(); } ( &lt;PRECEDING&gt; { return SqlWindow.createUnboundedPreceding(s.end(this)); } | &lt;FOLLOWING&gt; { return SqlWindow.createUnboundedFollowing(s.end(this)); } ) | e = Expression(ExprContext.ACCEPT_NON_QUERY) ( &lt;PRECEDING&gt; { return SqlWindow.createPreceding(e, getPos()); } | &lt;FOLLOWING&gt; { return SqlWindow.createFollowing(e, getPos()); } ) } Parses an ORDER BY clause. SqlNodeList OrderBy(boolean accept) : { List&lt;SqlNode&gt; list; SqlNode e; final Span s; } { &lt;ORDER&gt; { s = span(); if (!accept) { Someone told us ORDER BY wasn't allowed here. So why did they bother calling us? To get the correct parser position for error reporting. throw SqlUtil.newContextException(s.pos(), RESOURCE.illegalOrderBy()); } } &lt;BY&gt; e = OrderItem() { list = startList(e); } ( NOTE jvs 6-Feb-2004: See comments at top of file for why hint is necessary here. LOOKAHEAD(2) &lt;COMMA&gt; e = OrderItem() { list.add(e); } ) { return new SqlNodeList(list, s.addAll(list).pos()); } } Parses one list item in an ORDER BY clause. SqlNode OrderItem() : { SqlNode e; } { e = Expression(ExprContext.ACCEPT_SUB_QUERY) ( &lt;ASC&gt; | &lt;DESC&gt; { e = SqlStdOperatorTable.DESC.createCall(getPos(), e); } )? ( LOOKAHEAD(2) &lt;NULLS&gt; &lt;FIRST&gt; { e = SqlStdOperatorTable.NULLS_FIRST.createCall(getPos(), e); } | &lt;NULLS&gt; &lt;LAST&gt; { e = SqlStdOperatorTable.NULLS_LAST.createCall(getPos(), e); } )? { return e; } } Parses a FOR SYSTEM_TIME clause following a table expression. SqlSnapshot Snapshot(SqlNode tableRef) : { final Span s; final SqlNode e; } { { s = span(); } &lt;FOR&gt; &lt;SYSTEM_TIME&gt; &lt;AS&gt; &lt;OF&gt; Syntax for temporal table in standard SQL 2011 IWD 9075-2:201?(E) 7.6 &lt;table reference&gt; supports grammar as following: 1. datetime literal 2. datetime value function, i.e. CURRENT_TIMESTAMP 3. datetime term in 1 or 2 +(or -) interval term We extend to support column reference, use Expression to simplify the parsing code. e = Expression(ExprContext.ACCEPT_NON_QUERY) { return new SqlSnapshot(s.end(this), tableRef, e); } } Parses a PIVOT clause following a table expression. SqlNode Pivot(SqlNode tableRef) : { final Span s; final Span s2; final List&lt;SqlNode&gt; aggList = new ArrayList&lt;SqlNode&gt;(); final List&lt;SqlNode&gt; valueList = new ArrayList&lt;SqlNode&gt;(); final SqlNodeList axisList; final SqlNodeList inList; } { &lt;PIVOT&gt; { s = span(); } &lt;LPAREN&gt; PivotAgg(aggList) ( &lt;COMMA&gt; PivotAgg(aggList) ) &lt;FOR&gt; axisList = SimpleIdentifierOrList() &lt;IN&gt; &lt;LPAREN&gt; { s2 = span(); } [ PivotValue(valueList) ( &lt;COMMA&gt; PivotValue(valueList) ) ] &lt;RPAREN&gt; { inList = new SqlNodeList(valueList, s2.end(this)); } &lt;RPAREN&gt; { return new SqlPivot(s.end(this), tableRef, new SqlNodeList(aggList, SqlParserPos.sum(aggList)), axisList, inList); } } void PivotAgg(List&lt;SqlNode&gt; list) : { final SqlNode e; final SqlIdentifier alias; } { e = NamedFunctionCall() ( [ &lt;AS&gt; ] alias = SimpleIdentifier() { list.add( SqlStdOperatorTable.AS.createCall(Span.of(e).end(this), e, alias)); } | { list.add(e); } ) } void PivotValue(List&lt;SqlNode&gt; list) : { final SqlNode e; final SqlNodeList tuple; final SqlIdentifier alias; } { e = RowConstructor() { tuple = SqlParserUtil.stripRow(e); } ( [ &lt;AS&gt; ] alias = SimpleIdentifier() { list.add( SqlStdOperatorTable.AS.createCall(Span.of(tuple).end(this), tuple, alias)); } | { list.add(tuple); } ) } Parses a MATCH_RECOGNIZE clause following a table expression. SqlMatchRecognize MatchRecognize(SqlNode tableRef) : { final Span s, s0, s1, s2; SqlNodeList measureList = SqlNodeList.EMPTY; SqlNodeList partitionList = SqlNodeList.EMPTY; SqlNodeList orderList = SqlNodeList.EMPTY; SqlNode pattern; SqlLiteral interval; SqlNodeList patternDefList; final SqlNode after; SqlParserPos pos; final SqlNode var; final SqlLiteral rowsPerMatch; SqlNodeList subsetList = SqlNodeList.EMPTY; SqlLiteral isStrictStarts = SqlLiteral.createBoolean(false, getPos()); SqlLiteral isStrictEnds = SqlLiteral.createBoolean(false, getPos()); } { &lt;MATCH_RECOGNIZE&gt; { s = span(); } &lt;LPAREN&gt; [ &lt;PARTITION&gt; { s2 = span(); } &lt;BY&gt; partitionList = ExpressionCommaList(s2, ExprContext.ACCEPT_NON_QUERY) ] [ orderList = OrderBy(true) ] [ &lt;MEASURES&gt; measureList = MeasureColumnCommaList(span()) ] ( &lt;ONE&gt; { s0 = span(); } &lt;ROW&gt; &lt;PER&gt; &lt;MATCH&gt; { rowsPerMatch = SqlMatchRecognize.RowsPerMatchOption.ONE_ROW.symbol(s0.end(this)); } | &lt;ALL&gt; { s0 = span(); } &lt;ROWS&gt; &lt;PER&gt; &lt;MATCH&gt; { rowsPerMatch = SqlMatchRecognize.RowsPerMatchOption.ALL_ROWS.symbol(s0.end(this)); } | { rowsPerMatch = null; } ) ( &lt;AFTER&gt; { s1 = span(); } &lt;MATCH&gt; &lt;SKIP_&gt; ( &lt;TO&gt; ( LOOKAHEAD(2) &lt;NEXT&gt; &lt;ROW&gt; { after = SqlMatchRecognize.AfterOption.SKIP_TO_NEXT_ROW .symbol(s1.end(this)); } | LOOKAHEAD(2) &lt;FIRST&gt; var = SimpleIdentifier() { after = SqlMatchRecognize.SKIP_TO_FIRST.createCall( s1.end(var), var); } | This &quot;LOOKAHEAD({true})&quot; is a workaround for Babel. Because of babel parser uses option &quot;LOOKAHEAD=2&quot; globally, JavaCC generates something like &quot;LOOKAHEAD(2, [&lt;LAST&gt;] SimpleIdentifier())&quot; here. But the correct LOOKAHEAD should be &quot;LOOKAHEAD(2, [ LOOKAHEAD(2, &lt;LAST&gt; SimpleIdentifier()) &lt;LAST&gt; ] SimpleIdentifier())&quot; which have the syntactic lookahead for &lt;LAST&gt; considered. Overall LOOKAHEAD({true}) is even better as this is the last branch in the choice. LOOKAHEAD({true}) [ LOOKAHEAD(2, &lt;LAST&gt; SimpleIdentifier()) &lt;LAST&gt; ] var = SimpleIdentifier() { after = SqlMatchRecognize.SKIP_TO_LAST.createCall( s1.end(var), var); } ) | &lt;PAST&gt; &lt;LAST&gt; &lt;ROW&gt; { after = SqlMatchRecognize.AfterOption.SKIP_PAST_LAST_ROW .symbol(s1.end(this)); } ) | { after = null; } ) &lt;PATTERN&gt; &lt;LPAREN&gt; ( &lt;CARET&gt; { isStrictStarts = SqlLiteral.createBoolean(true, getPos()); } | { isStrictStarts = SqlLiteral.createBoolean(false, getPos()); } ) pattern = PatternExpression() ( &lt;DOLLAR&gt; { isStrictEnds = SqlLiteral.createBoolean(true, getPos()); } | { isStrictEnds = SqlLiteral.createBoolean(false, getPos()); } ) &lt;RPAREN&gt; ( &lt;WITHIN&gt; interval = IntervalLiteral() | { interval = null; } ) [ &lt;SUBSET&gt; subsetList = SubsetDefinitionCommaList(span()) ] &lt;DEFINE&gt; patternDefList = PatternDefinitionCommaList(span()) &lt;RPAREN&gt; { return new SqlMatchRecognize(s.end(this), tableRef, pattern, isStrictStarts, isStrictEnds, patternDefList, measureList, after, subsetList, rowsPerMatch, partitionList, orderList, interval); } } SqlNodeList MeasureColumnCommaList(Span s) : { SqlNode e; final List&lt;SqlNode&gt; eList = new ArrayList&lt;SqlNode&gt;(); } { e = MeasureColumn() { eList.add(e); } ( &lt;COMMA&gt; e = MeasureColumn() { eList.add(e); } ) { return new SqlNodeList(eList, s.addAll(eList).pos()); } } SqlNode MeasureColumn() : { SqlNode e; SqlIdentifier alias; } { e = Expression(ExprContext.ACCEPT_NON_QUERY) &lt;AS&gt; alias = SimpleIdentifier() { return SqlStdOperatorTable.AS.createCall(Span.of(e).end(this), e, alias); } } SqlNode PatternExpression() : { SqlNode left; SqlNode right; } { left = PatternTerm() ( &lt;VERTICAL_BAR&gt; right = PatternTerm() { left = SqlStdOperatorTable.PATTERN_ALTER.createCall( Span.of(left).end(right), left, right); } ) { return left; } } SqlNode PatternTerm() : { SqlNode left; SqlNode right; } { left = PatternFactor() ( right = PatternFactor() { left = SqlStdOperatorTable.PATTERN_CONCAT.createCall( Span.of(left).end(right), left, right); } ) { return left; } } SqlNode PatternFactor() : { SqlNode e; SqlNode extra; SqlLiteral startNum = null; SqlLiteral endNum = null; SqlLiteral reluctant = SqlLiteral.createBoolean(false, SqlParserPos.ZERO); } { e = PatternPrimary() [ LOOKAHEAD(1) ( &lt;STAR&gt; { startNum = SqlLiteral.createExactNumeric(&quot;0&quot;, SqlParserPos.ZERO); endNum = SqlLiteral.createExactNumeric(&quot;-1&quot;, SqlParserPos.ZERO); } | &lt;PLUS&gt; { startNum = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO); endNum = SqlLiteral.createExactNumeric(&quot;-1&quot;, SqlParserPos.ZERO); } | &lt;HOOK&gt; { startNum = SqlLiteral.createExactNumeric(&quot;0&quot;, SqlParserPos.ZERO); endNum = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO); } | &lt;LBRACE&gt; ( startNum = UnsignedNumericLiteral() { endNum = startNum; } [ &lt;COMMA&gt; { endNum = SqlLiteral.createExactNumeric(&quot;-1&quot;, SqlParserPos.ZERO); } [ endNum = UnsignedNumericLiteral() ] ] &lt;RBRACE&gt; | { startNum = SqlLiteral.createExactNumeric(&quot;-1&quot;, SqlParserPos.ZERO); } &lt;COMMA&gt; endNum = UnsignedNumericLiteral() &lt;RBRACE&gt; | &lt;MINUS&gt; extra = PatternExpression() &lt;MINUS&gt; &lt;RBRACE&gt; { extra = SqlStdOperatorTable.PATTERN_EXCLUDE.createCall( Span.of(extra).end(this), extra); e = SqlStdOperatorTable.PATTERN_CONCAT.createCall( Span.of(e).end(this), e, extra); return e; } ) ) [ &lt;HOOK&gt; { if (startNum.intValue(true) != endNum.intValue(true)) { reluctant = SqlLiteral.createBoolean(true, SqlParserPos.ZERO); } } ] ] { if (startNum == null) { return e; } else { return SqlStdOperatorTable.PATTERN_QUANTIFIER.createCall( span().end(e), e, startNum, endNum, reluctant); } } } SqlNode PatternPrimary() : { final Span s; SqlNode e; List&lt;SqlNode&gt; eList; } { ( e = SimpleIdentifier() | &lt;LPAREN&gt; e = PatternExpression() &lt;RPAREN&gt; | &lt;LBRACE&gt; { s = span(); } &lt;MINUS&gt; e = PatternExpression() &lt;MINUS&gt; &lt;RBRACE&gt; { e = SqlStdOperatorTable.PATTERN_EXCLUDE.createCall(s.end(this), e); } | ( &lt;PERMUTE&gt; { s = span(); } &lt;LPAREN&gt; e = PatternExpression() { eList = new ArrayList&lt;SqlNode&gt;(); eList.add(e); } ( &lt;COMMA&gt; e = PatternExpression() { eList.add(e); } ) &lt;RPAREN&gt; { e = SqlStdOperatorTable.PATTERN_PERMUTE.createCall( s.end(this), eList); } ) ) { return e; } } SqlNodeList SubsetDefinitionCommaList(Span s) : { SqlNode e; final List&lt;SqlNode&gt; eList = new ArrayList&lt;SqlNode&gt;(); } { e = SubsetDefinition() { eList.add(e); } ( &lt;COMMA&gt; e = SubsetDefinition() { eList.add(e); } ) { return new SqlNodeList(eList, s.addAll(eList).pos()); } } SqlNode SubsetDefinition() : { final SqlNode var; final SqlNodeList varList; } { var = SimpleIdentifier() &lt;EQ&gt; &lt;LPAREN&gt; varList = ExpressionCommaList(span(), ExprContext.ACCEPT_NON_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.EQUALS.createCall(span().end(var), var, varList); } } SqlNodeList PatternDefinitionCommaList(Span s) : { SqlNode e; final List&lt;SqlNode&gt; eList = new ArrayList&lt;SqlNode&gt;(); } { e = PatternDefinition() { eList.add(e); } ( &lt;COMMA&gt; e = PatternDefinition() { eList.add(e); } ) { return new SqlNodeList(eList, s.addAll(eList).pos()); } } SqlNode PatternDefinition() : { final SqlNode var; final SqlNode e; } { var = SimpleIdentifier() &lt;AS&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { return SqlStdOperatorTable.AS.createCall(Span.of(var, e).pos(), e, var); } } ---------------------------------------------------------------------------- Expressions Parses a SQL expression (such as might occur in a WHERE clause) followed by the end-of-file symbol. SqlNode SqlExpressionEof() : { SqlNode e; } { e = Expression(ExprContext.ACCEPT_SUB_QUERY) (&lt;EOF&gt;) { return e; } } Parses either a row expression or a query expression without ORDER BY. SqlNode QueryOrExpr(ExprContext exprContext) : { SqlNodeList withList = null; SqlNode e; SqlOperator op; SqlParserPos pos; SqlParserPos withPos; List&lt;Object&gt; list; } { [ withList = WithList() ] e = LeafQueryOrExpr(exprContext) { list = startList(e); } ( { if (!e.isA(SqlKind.QUERY)) { whoops, expression we just parsed wasn't a query, but we're about to see something like UNION, so force an exception retroactively checkNonQueryExpression(ExprContext.ACCEPT_QUERY); } } op = BinaryQueryOperator() { ensure a query is legal in this context pos = getPos(); checkQueryExpression(exprContext); } e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY) { list.add(new SqlParserUtil.ToTreeListItem(op, pos)); list.add(e); } ) { e = SqlParserUtil.toTree(list); if (withList != null) { e = new SqlWith(withList.getParserPosition(), withList, e); } return e; } } SqlNodeList WithList() : { SqlWithItem withItem; SqlParserPos pos; SqlNodeList list; } { &lt;WITH&gt; { list = new SqlNodeList(getPos()); } withItem = WithItem() {list.add(withItem);} ( &lt;COMMA&gt; withItem = WithItem() {list.add(withItem);} ) { return list; } } SqlWithItem WithItem() : { SqlIdentifier id; SqlNodeList columnList = null; SqlNode definition; } { id = SimpleIdentifier() [ LOOKAHEAD(2) columnList = ParenthesizedSimpleIdentifierList() ] &lt;AS&gt; definition = ParenthesizedExpression(ExprContext.ACCEPT_QUERY) { return new SqlWithItem(id.getParserPosition(), id, columnList, definition); } } Parses either a row expression, a leaf query expression, or a parenthesized expression of any kind. SqlNode LeafQueryOrExpr(ExprContext exprContext) : { SqlNode e; } { e = Expression(exprContext) { return e; } | e = LeafQuery(exprContext) { return e; } } Parses a row expression or a parenthesized expression of any kind. SqlNode Expression(ExprContext exprContext) : { List&lt;Object&gt; list; SqlNode e; } { list = Expression2(exprContext) { e = SqlParserUtil.toTree(list); return e; } } TODO jvs 15-Nov-2003: ANYALL void Expression2b(ExprContext exprContext, List&lt;Object&gt; list) : { SqlNode e; SqlOperator op; SqlNode ext; } { ( LOOKAHEAD(1) op = PrefixRowOperator() { checkNonQueryExpression(exprContext); list.add(new SqlParserUtil.ToTreeListItem(op, getPos())); } ) e = Expression3(exprContext) { list.add(e); } ( LOOKAHEAD(2) &lt;DOT&gt; ext = RowExpressionExtension() { list.add( new SqlParserUtil.ToTreeListItem( SqlStdOperatorTable.DOT, getPos())); list.add(ext); } ) } Parses a binary row expression, or a parenthesized expression of any kind. &lt;p&gt;The result is as a flat list of operators and operands. The top-level call to get an expression should call {@link Expression}, but lower-level calls should call this, to give the parser the opportunity to associate operator calls. &lt;p&gt;For example 'a = b like c = d' should come out '((a = b) like c) = d' because LIKE and '=' have the same precedence, but tends to come out as '(a = b) like (c = d)' because (a = b) and (c = d) are parsed as separate expressions. List&lt;Object&gt; Expression2(ExprContext exprContext) : { final List&lt;Object&gt; list = new ArrayList(); List&lt;Object&gt; list2; final List&lt;Object&gt; list3 = new ArrayList(); SqlNodeList nodeList; SqlNode e; SqlOperator op; SqlIdentifier p; final Span s = span(); } { Expression2b(exprContext, list) ( LOOKAHEAD(2) ( LOOKAHEAD(2) ( Special case for &quot;IN&quot;, because RHS of &quot;IN&quot; is the only place that an expression-list is allowed (&quot;exp IN (exp1, exp2)&quot;). LOOKAHEAD(2) { checkNonQueryExpression(exprContext); } ( &lt;NOT&gt; &lt;IN&gt; { op = SqlStdOperatorTable.NOT_IN; } | &lt;IN&gt; { op = SqlStdOperatorTable.IN; } | { final SqlKind k; } k = comp() ( &lt;SOME&gt; { op = SqlStdOperatorTable.some(k); } | &lt;ANY&gt; { op = SqlStdOperatorTable.some(k); } | &lt;ALL&gt; { op = SqlStdOperatorTable.all(k); } ) ) { s.clear().add(this); } nodeList = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_NONCURSOR) { list.add(new SqlParserUtil.ToTreeListItem(op, s.pos())); s.add(nodeList); special case for stuff like IN (s1 UNION s2) if (nodeList.size() == 1) { SqlNode item = nodeList.get(0); if (item.isA(SqlKind.QUERY)) { list.add(item); } else { list.add(nodeList); } } else { list.add(nodeList); } } | LOOKAHEAD(2) { checkNonQueryExpression(exprContext); } ( &lt;NOT&gt; &lt;BETWEEN&gt; { Modified by Jinbao Cheng on 2021-6-18 14:59 op = com.qpaas.db.sql.fun.SqlOperators.NOT_BETWEEN; s.clear().add(this); } [ &lt;SYMMETRIC&gt; { op = SqlStdOperatorTable.SYMMETRIC_NOT_BETWEEN; } | &lt;ASYMMETRIC&gt; ] | &lt;BETWEEN&gt; { Modified by Jinbao Cheng on 2021-6-18 14:59 op = com.qpaas.db.sql.fun.SqlOperators.BETWEEN; s.clear().add(this); } [ &lt;SYMMETRIC&gt; { op = SqlStdOperatorTable.SYMMETRIC_BETWEEN; } | &lt;ASYMMETRIC&gt; ] ) Expression2b(ExprContext.ACCEPT_SUB_QUERY, list3) { list.add(new SqlParserUtil.ToTreeListItem(op, s.pos())); list.addAll(list3); list3.clear(); } | LOOKAHEAD(2) { checkNonQueryExpression(exprContext); s.clear().add(this); } ( ( &lt;NOT&gt; ( &lt;LIKE&gt; { op = SqlStdOperatorTable.NOT_LIKE; } | &lt;SIMILAR&gt; &lt;TO&gt; { op = SqlStdOperatorTable.NOT_SIMILAR_TO; } ) | &lt;LIKE&gt; { op = SqlStdOperatorTable.LIKE; } | &lt;SIMILAR&gt; &lt;TO&gt; { op = SqlStdOperatorTable.SIMILAR_TO; } ) &lt;if (parser.includePosixOperators!default.parser.includePosixOperators)&gt; | &lt;NEGATE&gt; &lt;TILDE&gt; { op = SqlStdOperatorTable.NEGATED_POSIX_REGEX_CASE_SENSITIVE; } [ &lt;STAR&gt; { op = SqlStdOperatorTable.NEGATED_POSIX_REGEX_CASE_INSENSITIVE; } ] | &lt;TILDE&gt; { op = SqlStdOperatorTable.POSIX_REGEX_CASE_SENSITIVE; } [ &lt;STAR&gt; { op = SqlStdOperatorTable.POSIX_REGEX_CASE_INSENSITIVE; } ] &lt;if&gt; ) list2 = Expression2(ExprContext.ACCEPT_SUB_QUERY) { list.add(new SqlParserUtil.ToTreeListItem(op, s.pos())); list.addAll(list2); } [ LOOKAHEAD(2) &lt;ESCAPE&gt; e = Expression3(ExprContext.ACCEPT_SUB_QUERY) { s.clear().add(this); list.add( new SqlParserUtil.ToTreeListItem( SqlStdOperatorTable.ESCAPE, s.pos())); list.add(e); } ] | &lt;list (parser.extraBinaryExpressions!default.parser.extraBinaryExpressions) as extra &gt; {extra}(list, exprContext, s) | &lt;list&gt; LOOKAHEAD(3) op = BinaryRowOperator() { checkNonQueryExpression(exprContext); list.add(new SqlParserUtil.ToTreeListItem(op, getPos())); } Expression2b(ExprContext.ACCEPT_SUB_QUERY, list) | &lt;LBRACKET&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) &lt;RBRACKET&gt; { list.add( new SqlParserUtil.ToTreeListItem( SqlStdOperatorTable.ITEM, getPos())); list.add(e); } ( LOOKAHEAD(2) &lt;DOT&gt; p = SimpleIdentifier() { list.add( new SqlParserUtil.ToTreeListItem( SqlStdOperatorTable.DOT, getPos())); list.add(p); } ) | { checkNonQueryExpression(exprContext); } op = PostfixRowOperator() { list.add(new SqlParserUtil.ToTreeListItem(op, getPos())); } ) )+ { return list; } | { return list; } ) } Parses a comparison operator inside a SOME ALL predicate. SqlKind comp() : { } { &lt;LT&gt; { return SqlKind.LESS_THAN; } | &lt;LE&gt; { return SqlKind.LESS_THAN_OR_EQUAL; } | &lt;GT&gt; { return SqlKind.GREATER_THAN; } | &lt;GE&gt; { return SqlKind.GREATER_THAN_OR_EQUAL; } | &lt;EQ&gt; { return SqlKind.EQUALS; } | &lt;NE&gt; { return SqlKind.NOT_EQUALS; } | &lt;NE2&gt; { if (!this.conformance.isBangEqualAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.bangEqualNotAllowed()); } return SqlKind.NOT_EQUALS; } } Parses a unary row expression, or a parenthesized expression of any kind. SqlNode Expression3(ExprContext exprContext) : { final SqlNode e; final SqlNodeList list; final SqlNodeList list1; final SqlNodeList list2; final SqlOperator op; final Span s; Span rowSpan = null; } { LOOKAHEAD(2) e = AtomicRowExpression() { checkNonQueryExpression(exprContext); return e; } | e = CursorExpression(exprContext) { return e; } | LOOKAHEAD(3) &lt;ROW&gt; { s = span(); } list = ParenthesizedSimpleIdentifierList() { if (exprContext != ExprContext.ACCEPT_ALL &amp;&amp; exprContext != ExprContext.ACCEPT_CURSOR &amp;&amp; !this.conformance.allowExplicitRowValueConstructor()) { throw SqlUtil.newContextException(s.end(list), RESOURCE.illegalRowExpression()); } return SqlStdOperatorTable.ROW.createCall(list); } | [ &lt;ROW&gt; { rowSpan = span(); } ] list1 = ParenthesizedQueryOrCommaList(exprContext) { if (rowSpan != null) { interpret as row constructor return SqlStdOperatorTable.ROW.createCall(rowSpan.end(list1), list1.toArray()); } } [ LOOKAHEAD(2) TODO: ( op = periodOperator() list2 = ParenthesizedQueryOrCommaList(exprContext) { if (list1.size() != 2 || list2.size() != 2) { throw SqlUtil.newContextException( list1.getParserPosition().plus( list2.getParserPosition()), RESOURCE.illegalOverlaps()); } for (SqlNode node : list2) { list1.add(node); } return op.createCall( list1.getParserPosition().plus(list2.getParserPosition()), list1.toArray()); } ) | ( e = IntervalQualifier() { if ((list1.size() == 1) &amp;&amp; list1.get(0) instanceof SqlCall) { final SqlCall call = (SqlCall) list1.get(0); if (call.getKind() == SqlKind.MINUS &amp;&amp; call.operandCount() == 2) { List&lt;SqlNode&gt; list3 = startList(call.operand(0)); list3.add(call.operand(1)); list3.add(e); return SqlStdOperatorTable.MINUS_DATE.createCall( Span.of(list1).end(this), list3); } } throw SqlUtil.newContextException(span().end(list1), RESOURCE.illegalMinusDate()); } ) ] { if (list1.size() == 1) { interpret as single value or query return list1.get(0); } else { interpret as row constructor return SqlStdOperatorTable.ROW.createCall(span().end(list1), list1.toArray()); } } } SqlOperator periodOperator() : { } { &lt;OVERLAPS&gt; { return SqlStdOperatorTable.OVERLAPS; } | LOOKAHEAD(2) &lt;IMMEDIATELY&gt; &lt;PRECEDES&gt; { return SqlStdOperatorTable.IMMEDIATELY_PRECEDES; } | &lt;PRECEDES&gt; { return SqlStdOperatorTable.PRECEDES; } | &lt;IMMEDIATELY&gt; &lt;SUCCEEDS&gt; { return SqlStdOperatorTable.IMMEDIATELY_SUCCEEDS; } | &lt;SUCCEEDS&gt; { return SqlStdOperatorTable.SUCCEEDS; } | &lt;EQUALS&gt; { return SqlStdOperatorTable.PERIOD_EQUALS; } } Parses a COLLATE clause SqlCollation CollateClause() : { } { &lt;COLLATE&gt; &lt;COLLATION_ID&gt; { return new SqlCollation( getToken(0).image, SqlCollation.Coercibility.EXPLICIT); } } Numeric literal or parameter; used in LIMIT, OFFSET and FETCH clauses. SqlNode UnsignedNumericLiteralOrParam() : { final SqlNode e; } { ( e = UnsignedNumericLiteral() | e = DynamicParam() ) { return e; } } Parses a row expression extension, it can be either an identifier, or a call to a named function. SqlNode RowExpressionExtension() : { final SqlFunctionCategory funcType; final SqlIdentifier p; final Span s; final List&lt;SqlNode&gt; args; SqlCall call; SqlNode e; SqlLiteral quantifier = null; } { p = SimpleIdentifier() { e = p; } ( LOOKAHEAD( &lt;LPAREN&gt; ) { s = span(); } { funcType = SqlFunctionCategory.USER_DEFINED_FUNCTION; } ( LOOKAHEAD(2) &lt;LPAREN&gt; &lt;STAR&gt; { args = startList(SqlIdentifier.star(getPos())); } &lt;RPAREN&gt; | LOOKAHEAD(2) &lt;LPAREN&gt; &lt;RPAREN&gt; { args = Collections.emptyList(); } | args = FunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) { quantifier = (SqlLiteral) args.get(0); args.remove(0); } ) { call = createCall(p, s.end(this), funcType, quantifier, args); e = call; } )? { return e; } } Parses an atomic row expression. SqlNode AtomicRowExpression() : { final SqlNode e; } { ( e = LiteralOrIntervalExpression() | e = DynamicParam() | LOOKAHEAD(2) e = BuiltinFunctionCall() | e = JdbcFunctionCall() | e = MultisetConstructor() | e = ArrayConstructor() | LOOKAHEAD(3) e = MapConstructor() | e = PeriodConstructor() | NOTE jvs 18-Jan-2005: use syntactic lookahead to discriminate compound identifiers from function calls in which the function name is a compound identifier LOOKAHEAD( [&lt;SPECIFIC&gt;] FunctionName() &lt;LPAREN&gt;) e = NamedFunctionCall() | e = ContextVariable() | e = CompoundIdentifier() | e = NewSpecification() | e = CaseExpression() | e = SequenceExpression() ) { return e; } } SqlNode CaseExpression() : { final Span whenSpan = Span.of(); final Span thenSpan = Span.of(); final Span s; SqlNode e; SqlNode caseIdentifier = null; SqlNode elseClause = null; List&lt;SqlNode&gt; whenList = new ArrayList&lt;SqlNode&gt;(); List&lt;SqlNode&gt; thenList = new ArrayList&lt;SqlNode&gt;(); } { &lt;CASE&gt; { s = span(); } [ caseIdentifier = Expression(ExprContext.ACCEPT_SUB_QUERY) ] ( &lt;WHEN&gt; { whenSpan.add(this); } e = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY) { if (((SqlNodeList) e).size() == 1) { e = ((SqlNodeList) e).get(0); } whenList.add(e); } &lt;THEN&gt; { thenSpan.add(this); } e = Expression(ExprContext.ACCEPT_SUB_QUERY) { thenList.add(e); } )+ [ &lt;ELSE&gt; elseClause = Expression(ExprContext.ACCEPT_SUB_QUERY) ] &lt;END&gt; { return SqlCase.createSwitched(s.end(this), caseIdentifier, new SqlNodeList(whenList, whenSpan.addAll(whenList).pos()), new SqlNodeList(thenList, thenSpan.addAll(thenList).pos()), elseClause); } } SqlCall SequenceExpression() : { final Span s; final SqlOperator f; final SqlNode sequenceRef; } { ( &lt;NEXT&gt; { f = SqlStdOperatorTable.NEXT_VALUE; s = span(); } | LOOKAHEAD(3) &lt;CURRENT&gt; { f = SqlStdOperatorTable.CURRENT_VALUE; s = span(); } ) &lt;VALUE&gt; &lt;FOR&gt; sequenceRef = CompoundIdentifier() { return f.createCall(s.end(sequenceRef), sequenceRef); } } Parses &quot;SET &amp;lt;NAME&amp;gt; = VALUE&quot; or &quot;RESET &amp;lt;NAME&amp;gt;&quot;, without a leading &quot;ALTER &amp;lt;SCOPE&amp;gt;&quot;. SqlSetOption SqlSetOption(Span s, String scope) : { SqlIdentifier name; final SqlNode val; } { ( &lt;SET&gt; { s.add(this); } name = CompoundIdentifier() &lt;EQ&gt; ( val = Literal() | val = SimpleIdentifier() | &lt;ON&gt; { OFF is handled by SimpleIdentifier, ON handled here. val = new SqlIdentifier(token.image.toUpperCase(Locale.ROOT), getPos()); } ) { return new SqlSetOption(s.end(val), scope, name, val); } | &lt;RESET&gt; { s.add(this); } ( name = CompoundIdentifier() | &lt;ALL&gt; { name = new SqlIdentifier(token.image.toUpperCase(Locale.ROOT), getPos()); } ) { return new SqlSetOption(s.end(name), scope, name, null); } ) } Parses an expression for setting or resetting an option in SQL, such as QUOTED_IDENTIFIERS, or explain plan level (physicallogical). SqlAlter SqlAlter() : { final Span s; final String scope; final SqlAlter alterNode; } { &lt;ALTER&gt; { s = span(); } scope = Scope() ( &lt;-- additional literal parser methods are included here --&gt; &lt;list (parser.alterStatementParserMethods!default.parser.alterStatementParserMethods) as method&gt; alterNode = {method}(s, scope) | &lt;list&gt; alterNode = SqlSetOption(s, scope) ) { return alterNode; } } String Scope() : { } { ( &lt;SYSTEM&gt; | &lt;SESSION&gt; ) { return token.image.toUpperCase(Locale.ROOT); } } &lt;if (parser.createStatementParserMethods!default.parser.createStatementParserMethods)?size != 0&gt; Parses a CREATE statement. SqlCreate SqlCreate() : { final Span s; boolean replace = false; final SqlCreate create; } { &lt;CREATE&gt; { s = span(); } [ &lt;OR&gt; &lt;REPLACE&gt; { replace = true; } ] ( &lt;-- additional literal parser methods are included here --&gt; &lt;list (parser.createStatementParserMethods!default.parser.createStatementParserMethods) as method&gt; create = {method}(s, replace) &lt;sep&gt;| LOOKAHEAD(2) &lt;sep&gt; &lt;list&gt; ) { return create; } } &lt;if&gt; &lt;if (parser.dropStatementParserMethods!default.parser.dropStatementParserMethods)?size != 0&gt; Parses a DROP statement. SqlDrop SqlDrop() : { final Span s; boolean replace = false; final SqlDrop drop; } { &lt;DROP&gt; { s = span(); } ( &lt;-- additional literal parser methods are included here --&gt; &lt;list (parser.dropStatementParserMethods!default.parser.dropStatementParserMethods) as method&gt; drop = {method}(s, replace) &lt;sep&gt;|&lt;sep&gt; &lt;list&gt; ) { return drop; } } &lt;if&gt; Parses a literal expression, allowing continued string literals. Usually returns an SqlLiteral, but a continued string literal is an SqlCall expression, which concatenates 2 or more string literals; the validator reduces this. &lt;p&gt;If the context allows both literals and expressions, use {@link LiteralOrIntervalExpression}, which requires less lookahead. SqlNode Literal() : { SqlNode e; } { ( e = NonIntervalLiteral() | e = IntervalLiteral() ) { return e; } } Parses a literal that is not an interval literal. SqlNode NonIntervalLiteral() : { final SqlNode e; } { ( e = NumericLiteral() | e = StringLiteral() | e = SpecialLiteral() | e = DateTimeLiteral() &lt;-- additional literal parser methods are included here --&gt; &lt;list (parser.literalParserMethods!default.parser.literalParserMethods) as method&gt; | e = {method} &lt;list&gt; ) { return e; } } Parses a literal or an interval expression. &lt;p&gt;We include them in the same production because it is difficult to distinguish interval literals from interval expression (both of which start with the {@code INTERVAL} keyword); this way, we can use less LOOKAHEAD. SqlNode LiteralOrIntervalExpression() : { final SqlNode e; } { ( e = IntervalLiteralOrExpression() | e = NonIntervalLiteral() ) { return e; } } Parses a unsigned numeric literal SqlNumericLiteral UnsignedNumericLiteral() : { } { &lt;UNSIGNED_INTEGER_LITERAL&gt; { return SqlLiteral.createExactNumeric(token.image, getPos()); } | &lt;DECIMAL_NUMERIC_LITERAL&gt; { return SqlLiteral.createExactNumeric(token.image, getPos()); } | &lt;APPROX_NUMERIC_LITERAL&gt; { return SqlLiteral.createApproxNumeric(token.image, getPos()); } } Parses a numeric literal (can be signed) SqlLiteral NumericLiteral() : { final SqlNumericLiteral num; final Span s; } { &lt;PLUS&gt; num = UnsignedNumericLiteral() { return num; } | &lt;MINUS&gt; { s = span(); } num = UnsignedNumericLiteral() { return SqlLiteral.createNegative(num, s.end(this)); } | num = UnsignedNumericLiteral() { return num; } } Parse a special literal keyword SqlLiteral SpecialLiteral() : { } { &lt;TRUE&gt; { return SqlLiteral.createBoolean(true, getPos()); } | &lt;FALSE&gt; { return SqlLiteral.createBoolean(false, getPos()); } | &lt;UNKNOWN&gt; { return SqlLiteral.createUnknown(getPos()); } | &lt;NULL&gt; { return SqlLiteral.createNull(getPos()); } } Parses a string literal. The literal may be continued onto several lines. For a simple literal, the result is an SqlLiteral. For a continued literal, the result is an SqlCall expression, which concatenates 2 or more string literals; the validator reduces this. @see SqlLiteralunchain(SqlNode) @see SqlLiteralstringValue(SqlNode) @return a literal expression SqlNode StringLiteral() : { String p; int nfrags = 0; List&lt;SqlLiteral&gt; frags = null; char unicodeEscapeChar = 0; String charSet = null; SqlCharStringLiteral literal; } { A continued string literal consists of a head fragment and one or more tail fragments. Since comments may occur between the fragments, and comments are special tokens, each fragment is a token. But since spaces or comments may not occur between the prefix and the first quote, the head fragment, with any prefix, is one token. &lt;BINARY_STRING_LITERAL&gt; { try { p = SqlParserUtil.trim(token.image, &quot;xX'&quot;); frags = startList(SqlLiteral.createBinaryString(p, getPos())); nfrags++; } catch (NumberFormatException ex) { throw SqlUtil.newContextException(getPos(), RESOURCE.illegalBinaryString(token.image)); } } ( The grammar is ambiguous when a continued literals and a character string alias are both possible. For example, in SELECT x'01'\n'ab' we prefer that 'ab' continues the literal, and is not an alias. The following LOOKAHEAD mutes the warning about ambiguity. LOOKAHEAD(1) &lt;QUOTED_STRING&gt; { try { p = SqlParserUtil.trim(token.image, &quot;'&quot;); no embedded quotes frags.add(SqlLiteral.createBinaryString(p, getPos())); nfrags++; } catch (NumberFormatException ex) { throw SqlUtil.newContextException(getPos(), RESOURCE.illegalBinaryString(token.image)); } } ) { assert (nfrags &gt; 0); if (nfrags == 1) { return frags.get(0); just the head fragment } else { SqlParserPos pos2 = SqlParserPos.sum(frags); return SqlStdOperatorTable.LITERAL_CHAIN.createCall(pos2, frags); } } | ( &lt;PREFIXED_STRING_LITERAL&gt; { charSet = SqlParserUtil.getCharacterSet(token.image); } | &lt;QUOTED_STRING&gt; | &lt;UNICODE_STRING_LITERAL&gt; { TODO jvs 2-Feb-2009: support the explicit specification of a character set for Unicode string literals, per SQL:2003 unicodeEscapeChar = BACKSLASH; charSet = &quot;UTF16&quot;; } ) { p = SqlParserUtil.parseString(token.image); try { literal = SqlLiteral.createCharString(p, charSet, getPos()); } catch (java.nio.charset.UnsupportedCharsetException e) { throw SqlUtil.newContextException(getPos(), RESOURCE.unknownCharacterSet(charSet)); } frags = startList(literal); nfrags++; } ( The grammar is ambiguous when a continued literals and a character string alias are both possible. For example, in SELECT 'taxi'\n'cab' we prefer that 'cab' continues the literal, and is not an alias. The following LOOKAHEAD mutes the warning about ambiguity. LOOKAHEAD(1) &lt;QUOTED_STRING&gt; { p = SqlParserUtil.parseString(token.image); try { literal = SqlLiteral.createCharString(p, charSet, getPos()); } catch (java.nio.charset.UnsupportedCharsetException e) { throw SqlUtil.newContextException(getPos(), RESOURCE.unknownCharacterSet(charSet)); } frags.add(literal); nfrags++; } ) [ &lt;UESCAPE&gt; &lt;QUOTED_STRING&gt; { if (unicodeEscapeChar == 0) { throw SqlUtil.newContextException(getPos(), RESOURCE.unicodeEscapeUnexpected()); } String s = SqlParserUtil.parseString(token.image); unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s); } ] { assert nfrags &gt; 0; if (nfrags == 1) { just the head fragment SqlLiteral lit = (SqlLiteral) frags.get(0); return lit.unescapeUnicode(unicodeEscapeChar); } else { SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]); for (int i = 0; i &lt; rands.length; ++i) { rands[i] = ((SqlLiteral) rands[i]).unescapeUnicode( unicodeEscapeChar); } SqlParserPos pos2 = SqlParserPos.sum(rands); return SqlStdOperatorTable.LITERAL_CHAIN.createCall(pos2, rands); } } | &lt;BIG_QUERY_DOUBLE_QUOTED_STRING&gt; { p = SqlParserUtil.strip(getToken(0).image, DQ, DQ, &quot;\\\&quot;&quot;, Casing.UNCHANGED); try { return SqlLiteral.createCharString(p, charSet, getPos()); } catch (java.nio.charset.UnsupportedCharsetException e) { throw SqlUtil.newContextException(getPos(), RESOURCE.unknownCharacterSet(charSet)); } } | &lt;BIG_QUERY_QUOTED_STRING&gt; { p = SqlParserUtil.strip(getToken(0).image, &quot;'&quot;, &quot;'&quot;, &quot;\\'&quot;, Casing.UNCHANGED); try { return SqlLiteral.createCharString(p, charSet, getPos()); } catch (java.nio.charset.UnsupportedCharsetException e) { throw SqlUtil.newContextException(getPos(), RESOURCE.unknownCharacterSet(charSet)); } } } Parses a datetime literal. SqlLiteral DateTimeLiteral() : { final String p; final Span s; } { &lt;LBRACE_D&gt; &lt;QUOTED_STRING&gt; { p = token.image; } &lt;RBRACE&gt; { return SqlParserUtil.parseDateLiteral(p, getPos()); } | &lt;LBRACE_T&gt; &lt;QUOTED_STRING&gt; { p = token.image; } &lt;RBRACE&gt; { return SqlParserUtil.parseTimeLiteral(p, getPos()); } | &lt;LBRACE_TS&gt; { s = span(); } &lt;QUOTED_STRING&gt; { p = token.image; } &lt;RBRACE&gt; { return SqlParserUtil.parseTimestampLiteral(p, s.end(this)); } | &lt;DATE&gt; { s = span(); } &lt;QUOTED_STRING&gt; { return SqlParserUtil.parseDateLiteral(token.image, s.end(this)); } | &lt;TIME&gt; { s = span(); } &lt;QUOTED_STRING&gt; { return SqlParserUtil.parseTimeLiteral(token.image, s.end(this)); } | &lt;TIMESTAMP&gt; { s = span(); } &lt;QUOTED_STRING&gt; { return SqlParserUtil.parseTimestampLiteral(token.image, s.end(this)); } } Parses a MULTISET constructor SqlNode MultisetConstructor() : { List&lt;SqlNode&gt; args; SqlNode e; final Span s; } { &lt;MULTISET&gt; { s = span(); } ( LOOKAHEAD(2) &lt;LPAREN&gt; by sub query &quot;MULTISET(SELECT FROM T)&quot; e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.MULTISET_QUERY.createCall( s.end(this), e); } | by enumeration &quot;MULTISET[e0, e1, ..., eN]&quot; &lt;LBRACKET&gt; TODO: do trigraph as well ??( ??) e = Expression(ExprContext.ACCEPT_NON_QUERY) { args = startList(e); } ( &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { args.add(e); } ) &lt;RBRACKET&gt; { return SqlStdOperatorTable.MULTISET_VALUE.createCall( s.end(this), args); } ) } Parses an ARRAY constructor SqlNode ArrayConstructor() : { SqlNodeList args; SqlNode e; final Span s; } { &lt;ARRAY&gt; { s = span(); } ( LOOKAHEAD(1) &lt;LPAREN&gt; by sub query &quot;MULTISET(SELECT FROM T)&quot; e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.ARRAY_QUERY.createCall( s.end(this), e); } | by enumeration &quot;ARRAY[e0, e1, ..., eN]&quot; &lt;LBRACKET&gt; TODO: do trigraph as well ??( ??) ( args = ExpressionCommaList(s, ExprContext.ACCEPT_NON_QUERY) | { args = SqlNodeList.EMPTY; } ) &lt;RBRACKET&gt; { return SqlStdOperatorTable.ARRAY_VALUE_CONSTRUCTOR.createCall( s.end(this), args.getList()); } ) } Parses a MAP constructor SqlNode MapConstructor() : { SqlNodeList args; SqlNode e; final Span s; } { &lt;MAP&gt; { s = span(); } ( LOOKAHEAD(1) &lt;LPAREN&gt; by sub query &quot;MAP (SELECT empno, deptno FROM emp)&quot; e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.MAP_QUERY.createCall( s.end(this), e); } | by enumeration &quot;MAP[k0, v0, ..., kN, vN]&quot; &lt;LBRACKET&gt; TODO: do trigraph as well ??( ??) ( args = ExpressionCommaList(s, ExprContext.ACCEPT_NON_QUERY) | { args = SqlNodeList.EMPTY; } ) &lt;RBRACKET&gt; { return SqlStdOperatorTable.MAP_VALUE_CONSTRUCTOR.createCall( s.end(this), args.getList()); } ) } Parses a PERIOD constructor SqlNode PeriodConstructor() : { final SqlNode e0, e1; final Span s; } { &lt;PERIOD&gt; { s = span(); } &lt;LPAREN&gt; e0 = Expression(ExprContext.ACCEPT_SUB_QUERY) &lt;COMMA&gt; e1 = Expression(ExprContext.ACCEPT_SUB_QUERY) &lt;RPAREN&gt; { return SqlStdOperatorTable.ROW.createCall(s.end(this), e0, e1); } } Parses an interval literal. SqlLiteral IntervalLiteral() : { final String p; final SqlIntervalQualifier intervalQualifier; int sign = 1; final Span s; } { &lt;INTERVAL&gt; { s = span(); } [ &lt;MINUS&gt; { sign = -1; } | &lt;PLUS&gt; { sign = 1; } ] &lt;QUOTED_STRING&gt; { p = token.image; } intervalQualifier = IntervalQualifier() { return SqlParserUtil.parseIntervalLiteral(s.end(intervalQualifier), sign, p, intervalQualifier); } } Parses an interval literal (e.g. {@code INTERVAL '2:3' HOUR TO MINUTE}) or an interval expression (e.g. {@code INTERVAL emp.empno MINUTE} or {@code INTERVAL 3 MONTHS}). SqlNode IntervalLiteralOrExpression() : { final String p; final SqlIntervalQualifier intervalQualifier; int sign = 1; final Span s; SqlNode e; } { &lt;INTERVAL&gt; { s = span(); } [ &lt;MINUS&gt; { sign = -1; } | &lt;PLUS&gt; { sign = 1; } ] ( literal (with quoted string) &lt;QUOTED_STRING&gt; { p = token.image; } intervalQualifier = IntervalQualifier() { return SqlParserUtil.parseIntervalLiteral(s.end(intervalQualifier), sign, p, intervalQualifier); } | To keep parsing simple, any expressions besides numeric literal and identifiers must be enclosed in parentheses. ( &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) &lt;RPAREN&gt; | e = UnsignedNumericLiteral() | e = CompoundIdentifier() ) intervalQualifier = IntervalQualifierStart() { if (sign == -1) { e = SqlStdOperatorTable.UNARY_MINUS.createCall(e.getParserPosition(), e); } return SqlStdOperatorTable.INTERVAL.createCall(s.end(this), e, intervalQualifier); } ) } TimeUnit Year() : { } { &lt;YEAR&gt; { return TimeUnit.YEAR; } | &lt;YEARS&gt; { return warn(TimeUnit.YEAR); } } TimeUnit Month() : { } { &lt;MONTH&gt; { return TimeUnit.MONTH; } | &lt;MONTHS&gt; { return warn(TimeUnit.MONTH); } } TimeUnit Day() : { } { &lt;DAY&gt; { return TimeUnit.DAY; } | &lt;DAYS&gt; { return warn(TimeUnit.DAY); } } TimeUnit Hour() : { } { &lt;HOUR&gt; { return TimeUnit.HOUR; } | &lt;HOURS&gt; { return warn(TimeUnit.HOUR); } } TimeUnit Minute() : { } { &lt;MINUTE&gt; { return TimeUnit.MINUTE; } | &lt;MINUTES&gt; { return warn(TimeUnit.MINUTE); } } TimeUnit Second() : { } { &lt;SECOND&gt; { return TimeUnit.SECOND; } | &lt;SECONDS&gt; { return warn(TimeUnit.SECOND); } } SqlIntervalQualifier IntervalQualifier() : { final Span s; final TimeUnit start; TimeUnit end = null; int startPrec = RelDataType.PRECISION_NOT_SPECIFIED; int secondFracPrec = RelDataType.PRECISION_NOT_SPECIFIED; } { ( start = Year() { s = span(); } startPrec = PrecisionOpt() [ LOOKAHEAD(2) &lt;TO&gt; end = Month() ] | start = Month() { s = span(); } startPrec = PrecisionOpt() | start = Day() { s = span(); } startPrec = PrecisionOpt() [ LOOKAHEAD(2) &lt;TO&gt; ( end = Hour() | end = Minute() | end = Second() secondFracPrec = PrecisionOpt() ) ] | start = Hour() { s = span(); } startPrec = PrecisionOpt() [ LOOKAHEAD(2) &lt;TO&gt; ( end = Minute() | end = Second() [ &lt;LPAREN&gt; secondFracPrec = UnsignedIntLiteral() &lt;RPAREN&gt; ] ) ] | start = Minute() { s = span(); } startPrec = PrecisionOpt() [ LOOKAHEAD(2) &lt;TO&gt; end = Second() [ &lt;LPAREN&gt; secondFracPrec = UnsignedIntLiteral() &lt;RPAREN&gt; ] ] | start = Second() { s = span(); } [ &lt;LPAREN&gt; startPrec = UnsignedIntLiteral() [ &lt;COMMA&gt; secondFracPrec = UnsignedIntLiteral() ] &lt;RPAREN&gt; ] ) { return new SqlIntervalQualifier(start, startPrec, end, secondFracPrec, s.end(this)); } } Interval qualifier without 'TO unit'. SqlIntervalQualifier IntervalQualifierStart() : { final Span s; final TimeUnit start; int startPrec = RelDataType.PRECISION_NOT_SPECIFIED; int secondFracPrec = RelDataType.PRECISION_NOT_SPECIFIED; } { ( ( start = Year() | start = Month() | start = Day() | start = Hour() | start = Minute() ) { s = span(); } startPrec = PrecisionOpt() | start = Second() { s = span(); } [ &lt;LPAREN&gt; startPrec = UnsignedIntLiteral() [ &lt;COMMA&gt; secondFracPrec = UnsignedIntLiteral() ] &lt;RPAREN&gt; ] ) { return new SqlIntervalQualifier(start, startPrec, null, secondFracPrec, s.end(this)); } } Parses time unit for EXTRACT, CEIL and FLOOR functions. Note that it does't include NANOSECOND and MICROSECOND. TimeUnit TimeUnit() : {} { &lt;MILLISECOND&gt; { return TimeUnit.MILLISECOND; } | &lt;SECOND&gt; { return TimeUnit.SECOND; } | &lt;MINUTE&gt; { return TimeUnit.MINUTE; } | &lt;HOUR&gt; { return TimeUnit.HOUR; } | &lt;DAY&gt; { return TimeUnit.DAY; } | &lt;DOW&gt; { return TimeUnit.DOW; } | &lt;DOY&gt; { return TimeUnit.DOY; } | &lt;ISODOW&gt; { return TimeUnit.ISODOW; } | &lt;ISOYEAR&gt; { return TimeUnit.ISOYEAR; } | &lt;WEEK&gt; { return TimeUnit.WEEK; } | &lt;MONTH&gt; { return TimeUnit.MONTH; } | &lt;QUARTER&gt; { return TimeUnit.QUARTER; } | &lt;YEAR&gt; { return TimeUnit.YEAR; } | &lt;EPOCH&gt; { return TimeUnit.EPOCH; } | &lt;DECADE&gt; { return TimeUnit.DECADE; } | &lt;CENTURY&gt; { return TimeUnit.CENTURY; } | &lt;MILLENNIUM&gt; { return TimeUnit.MILLENNIUM; } } TimeUnit TimestampInterval() : {} { &lt;FRAC_SECOND&gt; { return TimeUnit.MICROSECOND; } | &lt;MICROSECOND&gt; { return TimeUnit.MICROSECOND; } | &lt;NANOSECOND&gt; { return TimeUnit.NANOSECOND; } | &lt;SQL_TSI_FRAC_SECOND&gt; { return TimeUnit.NANOSECOND; } | &lt;SQL_TSI_MICROSECOND&gt; { return TimeUnit.MICROSECOND; } | &lt;SECOND&gt; { return TimeUnit.SECOND; } | &lt;SQL_TSI_SECOND&gt; { return TimeUnit.SECOND; } | &lt;MINUTE&gt; { return TimeUnit.MINUTE; } | &lt;SQL_TSI_MINUTE&gt; { return TimeUnit.MINUTE; } | &lt;HOUR&gt; { return TimeUnit.HOUR; } | &lt;SQL_TSI_HOUR&gt; { return TimeUnit.HOUR; } | &lt;DAY&gt; { return TimeUnit.DAY; } | &lt;SQL_TSI_DAY&gt; { return TimeUnit.DAY; } | &lt;WEEK&gt; { return TimeUnit.WEEK; } | &lt;SQL_TSI_WEEK&gt; { return TimeUnit.WEEK; } | &lt;MONTH&gt; { return TimeUnit.MONTH; } | &lt;SQL_TSI_MONTH&gt; { return TimeUnit.MONTH; } | &lt;QUARTER&gt; { return TimeUnit.QUARTER; } | &lt;SQL_TSI_QUARTER&gt; { return TimeUnit.QUARTER; } | &lt;YEAR&gt; { return TimeUnit.YEAR; } | &lt;SQL_TSI_YEAR&gt; { return TimeUnit.YEAR; } } Parses a dynamic parameter marker. SqlDynamicParam DynamicParam() : { } { &lt;HOOK&gt; { return new SqlDynamicParam(nDynamicParams++, getPos()); } } Parses one segment of an identifier that may be composite. &lt;p&gt;Each time it reads an identifier it writes one element to each list; the entry in {@code positions} records its position and whether the segment was quoted. void IdentifierSegment(List&lt;String&gt; names, List&lt;SqlParserPos&gt; positions) : { final String id; char unicodeEscapeChar = BACKSLASH; final SqlParserPos pos; final Span span; } { ( &lt;IDENTIFIER&gt; { id = unquotedIdentifier(); pos = getPos(); } | &lt;HYPHENATED_IDENTIFIER&gt; { id = unquotedIdentifier(); pos = getPos(); } | &lt;QUOTED_IDENTIFIER&gt; { id = SqlParserUtil.strip(getToken(0).image, DQ, DQ, DQDQ, quotedCasing); pos = getPos().withQuoting(true); } | &lt;BACK_QUOTED_IDENTIFIER&gt; { id = SqlParserUtil.strip(getToken(0).image, &quot;`&quot;, &quot;`&quot;, &quot;``&quot;, quotedCasing); pos = getPos().withQuoting(true); } | &lt;BRACKET_QUOTED_IDENTIFIER&gt; { id = SqlParserUtil.strip(getToken(0).image, &quot;[&quot;, &quot;]&quot;, &quot;]]&quot;, quotedCasing); pos = getPos().withQuoting(true); } | &lt;UNICODE_QUOTED_IDENTIFIER&gt; { span = span(); String image = getToken(0).image; image = image.substring(image.indexOf('&quot;')); image = SqlParserUtil.strip(image, DQ, DQ, DQDQ, quotedCasing); } [ &lt;UESCAPE&gt; &lt;QUOTED_STRING&gt; { String s = SqlParserUtil.parseString(token.image); unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s); } ] { pos = span.end(this).withQuoting(true); SqlLiteral lit = SqlLiteral.createCharString(image, &quot;UTF16&quot;, pos); lit = lit.unescapeUnicode(unicodeEscapeChar); id = lit.toValue(); } | id = NonReservedKeyWord() { pos = getPos(); } ) { if (id.length() &gt; this.identifierMaxLength) { throw SqlUtil.newContextException(pos, RESOURCE.identifierTooLong(id, this.identifierMaxLength)); } names.add(id); if (positions != null) { positions.add(pos); } } } As {@link IdentifierSegment} but part of a table name (for example, following {@code FROM}, {@code INSERT} or {@code UPDATE}). &lt;p&gt;In some dialects the lexical rules for table names are different from for other identifiers. For example, in BigQuery, table names may contain hyphens. void TableIdentifierSegment(List&lt;String&gt; names, List&lt;SqlParserPos&gt; positions) : { } { IdentifierSegment(names, positions) { final int n = names.size(); if (n &gt; 0 &amp;&amp; positions.size() == n &amp;&amp; names.get(n - 1).contains(&quot;.&quot;) &amp;&amp; positions.get(n - 1).isQuoted() &amp;&amp; this.conformance.splitQuotedTableName()) { final String name = names.remove(n - 1); final SqlParserPos pos = positions.remove(n - 1); final String[] splitNames = name.split(&quot;\\.&quot;); for (String splitName : splitNames) { names.add(splitName); positions.add(pos); } } } } Parses a simple identifier as a String. String Identifier() : { final List&lt;String&gt; names = new ArrayList&lt;String&gt;(); } { IdentifierSegment(names, null) { return names.get(0); } } Parses a simple identifier as an SqlIdentifier. SqlIdentifier SimpleIdentifier() : { final List&lt;String&gt; names = new ArrayList&lt;String&gt;(); final List&lt;SqlParserPos&gt; positions = new ArrayList&lt;SqlParserPos&gt;(); } { IdentifierSegment(names, positions) { return new SqlIdentifier(names.get(0), positions.get(0)); } } Parses a character literal as an SqlIdentifier. Only valid for column aliases in certain dialects. SqlIdentifier SimpleIdentifierFromStringLiteral() : { } { &lt;QUOTED_STRING&gt; { if (!this.conformance.allowCharLiteralAlias()) { throw SqlUtil.newContextException(getPos(), RESOURCE.charLiteralAliasNotValid()); } final String s = SqlParserUtil.parseString(token.image); return new SqlIdentifier(s, getPos()); } } Parses a comma-separated list of simple identifiers. void SimpleIdentifierCommaList(List&lt;SqlNode&gt; list) : { SqlIdentifier id; } { id = SimpleIdentifier() {list.add(id);} ( &lt;COMMA&gt; id = SimpleIdentifier() { list.add(id); } ) } List of simple identifiers in parentheses. The position extends from the open parenthesis to the close parenthesis. SqlNodeList ParenthesizedSimpleIdentifierList() : { final Span s; final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); } { &lt;LPAREN&gt; { s = span(); } SimpleIdentifierCommaList(list) &lt;RPAREN&gt; { return new SqlNodeList(list, s.end(this)); } } List of simple identifiers in parentheses or one simple identifier. &lt;ul&gt;Examples: &lt;li&gt;{@code DEPTNO} &lt;li&gt;{@code (EMPNO, DEPTNO)} &lt;ul&gt; SqlNodeList SimpleIdentifierOrList() : { SqlIdentifier id; SqlNodeList list; } { id = SimpleIdentifier() { return new SqlNodeList(Collections.singletonList(id), id.getParserPosition()); } | list = ParenthesizedSimpleIdentifierList() { return list; } } &lt;if (parser.includeCompoundIdentifier!default.parser.includeCompoundIdentifier) &gt; Parses a compound identifier. SqlIdentifier CompoundIdentifier() : { final List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); final List&lt;SqlParserPos&gt; posList = new ArrayList&lt;SqlParserPos&gt;(); boolean star = false; } { IdentifierSegment(nameList, posList) ( LOOKAHEAD(2) &lt;DOT&gt; IdentifierSegment(nameList, posList) ) ( LOOKAHEAD(2) &lt;DOT&gt; &lt;STAR&gt; { star = true; nameList.add(&quot;&quot;); posList.add(getPos()); } )? { SqlParserPos pos = SqlParserPos.sum(posList); if (star) { return SqlIdentifier.star(nameList, pos, posList); } return new SqlIdentifier(nameList, null, pos, posList); } } Parses a compound identifier in the FROM clause. SqlIdentifier CompoundTableIdentifier() : { final List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); final List&lt;SqlParserPos&gt; posList = new ArrayList&lt;SqlParserPos&gt;(); } { TableIdentifierSegment(nameList, posList) ( LOOKAHEAD(2) &lt;DOT&gt; TableIdentifierSegment(nameList, posList) ) { SqlParserPos pos = SqlParserPos.sum(posList); return new SqlIdentifier(nameList, null, pos, posList); } } Parses a comma-separated list of compound identifiers. void CompoundIdentifierTypeCommaList(List&lt;SqlNode&gt; list, List&lt;SqlNode&gt; extendList) : { } { CompoundIdentifierType(list, extendList) (&lt;COMMA&gt; CompoundIdentifierType(list, extendList)) } List of compound identifiers in parentheses. The position extends from the open parenthesis to the close parenthesis. Pair&lt;SqlNodeList, SqlNodeList&gt; ParenthesizedCompoundIdentifierList() : { final Span s; final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); final List&lt;SqlNode&gt; extendList = new ArrayList&lt;SqlNode&gt;(); } { &lt;LPAREN&gt; { s = span(); } CompoundIdentifierTypeCommaList(list, extendList) &lt;RPAREN&gt; { return Pair.of(new SqlNodeList(list, s.end(this)), new SqlNodeList(extendList, s.end(this))); } } &lt;else&gt; &lt;include &quot;@includescompoundIdentifier.ftl&quot; &gt; &lt;if&gt; Parses a NEW UDT(...) expression. SqlNode NewSpecification() : { final Span s; final SqlNode routineCall; } { &lt;NEW&gt; { s = span(); } routineCall = NamedRoutineCall(SqlFunctionCategory.USER_DEFINED_CONSTRUCTOR, ExprContext.ACCEPT_SUB_QUERY) { return SqlStdOperatorTable.NEW.createCall(s.end(routineCall), routineCall); } } TODO: real parse errors. int UnsignedIntLiteral() : { Token t; } { t = &lt;UNSIGNED_INTEGER_LITERAL&gt; { try { return Integer.parseInt(t.image); } catch (NumberFormatException ex) { throw SqlUtil.newContextException(getPos(), RESOURCE.invalidLiteral(t.image, Integer.class.getCanonicalName())); } } } int IntLiteral() : { Token t; } { ( t = &lt;UNSIGNED_INTEGER_LITERAL&gt; | &lt;PLUS&gt; t = &lt;UNSIGNED_INTEGER_LITERAL&gt; ) { try { return Integer.parseInt(t.image); } catch (NumberFormatException ex) { throw SqlUtil.newContextException(getPos(), RESOURCE.invalidLiteral(t.image, Integer.class.getCanonicalName())); } } | &lt;MINUS&gt; t = &lt;UNSIGNED_INTEGER_LITERAL&gt; { try { return -Integer.parseInt(t.image); } catch (NumberFormatException ex) { throw SqlUtil.newContextException(getPos(), RESOURCE.invalidLiteral(t.image, Integer.class.getCanonicalName())); } } } Type name with optional scale and precision. SqlDataTypeSpec DataType() : { SqlTypeNameSpec typeName; final Span s; } { typeName = TypeName() { s = Span.of(typeName.getParserPos()); } ( typeName = CollectionsTypeName(typeName) ) { return new SqlDataTypeSpec(typeName, s.add(typeName.getParserPos()).pos()); } } Some SQL type names need special handling due to the fact that they have spaces in them but are not quoted. SqlTypeNameSpec TypeName() : { final SqlTypeNameSpec typeNameSpec; final SqlIdentifier typeName; final Span s = Span.of(); } { ( &lt;-- additional types are included here --&gt; &lt;-- put custom data types in front of Calcite core data types --&gt; &lt;list (parser.dataTypeParserMethods!default.parser.dataTypeParserMethods) as method&gt; LOOKAHEAD(2) typeNameSpec = {method} | &lt;list&gt; LOOKAHEAD(2) typeNameSpec = SqlTypeName(s) | typeNameSpec = RowTypeName() | typeName = CompoundIdentifier() { typeNameSpec = new SqlUserDefinedTypeNameSpec(typeName, s.end(this)); } ) { return typeNameSpec; } } Types used for JDBC and ODBC scalar conversion function SqlTypeNameSpec SqlTypeName(Span s) : { final SqlTypeNameSpec sqlTypeNameSpec; } { ( sqlTypeNameSpec = SqlTypeName1(s) | sqlTypeNameSpec = SqlTypeName2(s) | sqlTypeNameSpec = SqlTypeName3(s) | sqlTypeNameSpec = CharacterTypeName(s) | sqlTypeNameSpec = DateTimeTypeName() ) { return sqlTypeNameSpec; } } Parse sql type name that don't allow any extra specifications except the type name. For extra specification, we mean precision, scale, charSet, etc. SqlTypeNameSpec SqlTypeName1(Span s) : { final SqlTypeName sqlTypeName; } { ( &lt;GEOMETRY&gt; { if (!this.conformance.allowGeometry()) { throw SqlUtil.newContextException(getPos(), RESOURCE.geometryDisabled()); } s.add(this); sqlTypeName = SqlTypeName.GEOMETRY; } | &lt;BOOLEAN&gt; { s.add(this); sqlTypeName = SqlTypeName.BOOLEAN; } | ( &lt;INTEGER&gt; | &lt;INT&gt; ) { s.add(this); sqlTypeName = SqlTypeName.INTEGER; } | &lt;TINYINT&gt; { s.add(this); sqlTypeName = SqlTypeName.TINYINT; } | &lt;SMALLINT&gt; { s.add(this); sqlTypeName = SqlTypeName.SMALLINT; } | &lt;BIGINT&gt; { s.add(this); sqlTypeName = SqlTypeName.BIGINT; } | &lt;REAL&gt; { s.add(this); sqlTypeName = SqlTypeName.REAL; } | &lt;DOUBLE&gt; { s.add(this); } [ &lt;PRECISION&gt; ] { sqlTypeName = SqlTypeName.DOUBLE; } | &lt;FLOAT&gt; { s.add(this); sqlTypeName = SqlTypeName.FLOAT; } ) { return new SqlBasicTypeNameSpec(sqlTypeName, s.end(this)); } } Parse sql type name that allows precision specification. SqlTypeNameSpec SqlTypeName2(Span s) : { final SqlTypeName sqlTypeName; int precision = -1; } { ( &lt;BINARY&gt; { s.add(this); } ( &lt;VARYING&gt; { sqlTypeName = SqlTypeName.VARBINARY; } | { sqlTypeName = SqlTypeName.BINARY; } ) | &lt;VARBINARY&gt; { s.add(this); sqlTypeName = SqlTypeName.VARBINARY; } ) precision = PrecisionOpt() { return new SqlBasicTypeNameSpec(sqlTypeName, precision, s.end(this)); } } Parse sql type name that allows precision and scale specifications. SqlTypeNameSpec SqlTypeName3(Span s) : { final SqlTypeName sqlTypeName; int precision = -1; int scale = -1; } { ( (&lt;DECIMAL&gt; | &lt;DEC&gt; | &lt;NUMERIC&gt;) { s.add(this); sqlTypeName = SqlTypeName.DECIMAL; } | &lt;ANY&gt; { s.add(this); sqlTypeName = SqlTypeName.ANY; } ) [ &lt;LPAREN&gt; precision = UnsignedIntLiteral() [ &lt;COMMA&gt; scale = UnsignedIntLiteral() ] &lt;RPAREN&gt; ] { return new SqlBasicTypeNameSpec(sqlTypeName, precision, scale, s.end(this)); } } Types used for for JDBC and ODBC scalar conversion function SqlJdbcDataTypeName JdbcOdbcDataTypeName() : { } { (&lt;SQL_CHAR&gt; | &lt;CHAR&gt;) { return SqlJdbcDataTypeName.SQL_CHAR; } | (&lt;SQL_VARCHAR&gt; | &lt;VARCHAR&gt;) { return SqlJdbcDataTypeName.SQL_VARCHAR; } | (&lt;SQL_DATE&gt; | &lt;DATE&gt;) { return SqlJdbcDataTypeName.SQL_DATE; } | (&lt;SQL_TIME&gt; | &lt;TIME&gt;) { return SqlJdbcDataTypeName.SQL_TIME; } | (&lt;SQL_TIMESTAMP&gt; | &lt;TIMESTAMP&gt;) { return SqlJdbcDataTypeName.SQL_TIMESTAMP; } | (&lt;SQL_DECIMAL&gt; | &lt;DECIMAL&gt;) { return SqlJdbcDataTypeName.SQL_DECIMAL; } | (&lt;SQL_NUMERIC&gt; | &lt;NUMERIC&gt;) { return SqlJdbcDataTypeName.SQL_NUMERIC; } | (&lt;SQL_BOOLEAN&gt; | &lt;BOOLEAN&gt;) { return SqlJdbcDataTypeName.SQL_BOOLEAN; } | (&lt;SQL_INTEGER&gt; | &lt;INTEGER&gt;) { return SqlJdbcDataTypeName.SQL_INTEGER; } | (&lt;SQL_BINARY&gt; | &lt;BINARY&gt;) { return SqlJdbcDataTypeName.SQL_BINARY; } | (&lt;SQL_VARBINARY&gt; | &lt;VARBINARY&gt;) { return SqlJdbcDataTypeName.SQL_VARBINARY; } | (&lt;SQL_TINYINT&gt; | &lt;TINYINT&gt;) { return SqlJdbcDataTypeName.SQL_TINYINT; } | (&lt;SQL_SMALLINT&gt; | &lt;SMALLINT&gt;) { return SqlJdbcDataTypeName.SQL_SMALLINT; } | (&lt;SQL_BIGINT&gt; | &lt;BIGINT&gt;) { return SqlJdbcDataTypeName.SQL_BIGINT; } | (&lt;SQL_REAL&gt;| &lt;REAL&gt;) { return SqlJdbcDataTypeName.SQL_REAL; } | (&lt;SQL_DOUBLE&gt; | &lt;DOUBLE&gt;) { return SqlJdbcDataTypeName.SQL_DOUBLE; } | (&lt;SQL_FLOAT&gt; | &lt;FLOAT&gt;) { return SqlJdbcDataTypeName.SQL_FLOAT; } | &lt;SQL_INTERVAL_YEAR&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_YEAR; } | &lt;SQL_INTERVAL_YEAR_TO_MONTH&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_YEAR_TO_MONTH; } | &lt;SQL_INTERVAL_MONTH&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_MONTH; } | &lt;SQL_INTERVAL_DAY&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY; } | &lt;SQL_INTERVAL_DAY_TO_HOUR&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_HOUR; } | &lt;SQL_INTERVAL_DAY_TO_MINUTE&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_MINUTE; } | &lt;SQL_INTERVAL_DAY_TO_SECOND&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_SECOND; } | &lt;SQL_INTERVAL_HOUR&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR; } | &lt;SQL_INTERVAL_HOUR_TO_MINUTE&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR_TO_MINUTE; } | &lt;SQL_INTERVAL_HOUR_TO_SECOND&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR_TO_SECOND; } | &lt;SQL_INTERVAL_MINUTE&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_MINUTE; } | &lt;SQL_INTERVAL_MINUTE_TO_SECOND&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_MINUTE_TO_SECOND; } | &lt;SQL_INTERVAL_SECOND&gt; { return SqlJdbcDataTypeName.SQL_INTERVAL_SECOND; } } SqlLiteral JdbcOdbcDataType() : { SqlJdbcDataTypeName typeName; } { typeName = JdbcOdbcDataTypeName() { return typeName.symbol(getPos()); } } Parse a collection type name, the input element type name may also be a collection type. SqlTypeNameSpec CollectionsTypeName(SqlTypeNameSpec elementTypeName) : { final SqlTypeName collectionTypeName; } { ( &lt;MULTISET&gt; { collectionTypeName = SqlTypeName.MULTISET; } | &lt;ARRAY&gt; { collectionTypeName = SqlTypeName.ARRAY; } ) { return new SqlCollectionTypeNameSpec(elementTypeName, collectionTypeName, getPos()); } } Parse a nullable option, default is true. boolean NullableOptDefaultTrue() : { } { &lt;NULL&gt; { return true; } | &lt;NOT&gt; &lt;NULL&gt; { return false; } | { return true; } } Parse a nullable option, default is false. boolean NullableOptDefaultFalse() : { } { &lt;NULL&gt; { return true; } | &lt;NOT&gt; &lt;NULL&gt; { return false; } | { return false; } } Parse a &quot;name1 type1 [NULL | NOT NULL], name2 type2 [NULL | NOT NULL] ...&quot; list, the field type default is not nullable. void FieldNameTypeCommaList( List&lt;SqlIdentifier&gt; fieldNames, List&lt;SqlDataTypeSpec&gt; fieldTypes) : { SqlIdentifier fName; SqlDataTypeSpec fType; boolean nullable; } { fName = SimpleIdentifier() fType = DataType() nullable = NullableOptDefaultFalse() { fieldNames.add(fName); fieldTypes.add(fType.withNullable(nullable, getPos())); } ( &lt;COMMA&gt; fName = SimpleIdentifier() fType = DataType() nullable = NullableOptDefaultFalse() { fieldNames.add(fName); fieldTypes.add(fType.withNullable(nullable, getPos())); } ) } Parse Row type with format: Row(name1 type1, name2 type2). Every field type can have suffix of `NULL` or `NOT NULL` to indicate if this type is nullable. i.e. Row(f0 int not null, f1 varchar null). SqlTypeNameSpec RowTypeName() : { List&lt;SqlIdentifier&gt; fieldNames = new ArrayList&lt;SqlIdentifier&gt;(); List&lt;SqlDataTypeSpec&gt; fieldTypes = new ArrayList&lt;SqlDataTypeSpec&gt;(); } { &lt;ROW&gt; &lt;LPAREN&gt; FieldNameTypeCommaList(fieldNames, fieldTypes) &lt;RPAREN&gt; { return new SqlRowTypeNameSpec(getPos(), fieldNames, fieldTypes); } } Parse character types: char, varchar. SqlTypeNameSpec CharacterTypeName(Span s) : { int precision = -1; final SqlTypeName sqlTypeName; String charSetName = null; } { ( (&lt;CHARACTER&gt; | &lt;CHAR&gt;) { s.add(this); } ( &lt;VARYING&gt; { sqlTypeName = SqlTypeName.VARCHAR; } | { sqlTypeName = SqlTypeName.CHAR; } ) | &lt;VARCHAR&gt; { s.add(this); sqlTypeName = SqlTypeName.VARCHAR; } ) precision = PrecisionOpt() [ &lt;CHARACTER&gt; &lt;SET&gt; charSetName = Identifier() ] { return new SqlBasicTypeNameSpec(sqlTypeName, precision, charSetName, s.end(this)); } } Parse datetime types: date, time, timestamp. SqlTypeNameSpec DateTimeTypeName() : { int precision = -1; SqlTypeName typeName; boolean withLocalTimeZone = false; final Span s; } { &lt;DATE&gt; { typeName = SqlTypeName.DATE; return new SqlBasicTypeNameSpec(typeName, getPos()); } | LOOKAHEAD(2) &lt;TIME&gt; { s = span(); } precision = PrecisionOpt() withLocalTimeZone = TimeZoneOpt() { if (withLocalTimeZone) { typeName = SqlTypeName.TIME_WITH_LOCAL_TIME_ZONE; } else { typeName = SqlTypeName.TIME; } return new SqlBasicTypeNameSpec(typeName, precision, s.end(this)); } | &lt;TIMESTAMP&gt; { s = span(); } precision = PrecisionOpt() withLocalTimeZone = TimeZoneOpt() { if (withLocalTimeZone) { typeName = SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE; } else { typeName = SqlTypeName.TIMESTAMP; } return new SqlBasicTypeNameSpec(typeName, precision, s.end(this)); } } Parse an optional data type precision, default is -1. int PrecisionOpt() : { int precision = -1; } { &lt;LPAREN&gt; precision = UnsignedIntLiteral() &lt;RPAREN&gt; { return precision; } | { return -1; } } Parse a time zone suffix for DateTime types. According to SQL-2011, &quot;with time zone&quot; and &quot;without time zone&quot; belong to standard SQL but we only implement the &quot;without time zone&quot;. &lt;p&gt;We also support &quot;with local time zone&quot;. @return true if this is &quot;with local time zone&quot;. boolean TimeZoneOpt() : { } { LOOKAHEAD(3) &lt;WITHOUT&gt; &lt;TIME&gt; &lt;ZONE&gt; { return false; } | &lt;WITH&gt; &lt;LOCAL&gt; &lt;TIME&gt; &lt;ZONE&gt; { return true; } | { return false; } } Parses a CURSOR(query) expression. The parser allows these anywhere, but the validator restricts them to appear only as arguments to table functions. SqlNode CursorExpression(ExprContext exprContext) : { final SqlNode e; final Span s; } { &lt;CURSOR&gt; { s = span(); if (exprContext != ExprContext.ACCEPT_ALL &amp;&amp; exprContext != ExprContext.ACCEPT_CURSOR) { throw SqlUtil.newContextException(s.end(this), RESOURCE.illegalCursorExpression()); } } e = Expression(ExprContext.ACCEPT_QUERY) { return SqlStdOperatorTable.CURSOR.createCall(s.end(e), e); } } Parses a call to a builtin function with special syntax. SqlNode BuiltinFunctionCall() : { final SqlIdentifier name; List&lt;SqlNode&gt; args = null; SqlNode e = null; final Span s; SqlDataTypeSpec dt; TimeUnit interval; final TimeUnit unit; final SqlNode node; } { ~ FUNCTIONS WITH SPECIAL SYNTAX --------------------------------------- ( &lt;CAST&gt; { s = span(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); } &lt;AS&gt; ( dt = DataType() { args.add(dt); } | &lt;INTERVAL&gt; e = IntervalQualifier() { args.add(e); } ) &lt;RPAREN&gt; { return SqlStdOperatorTable.CAST.createCall(s.end(this), args); } | &lt;EXTRACT&gt; { s = span(); } &lt;LPAREN&gt; ( &lt;NANOSECOND&gt; { unit = TimeUnit.NANOSECOND; } | &lt;MICROSECOND&gt; { unit = TimeUnit.MICROSECOND; } | unit = TimeUnit() ) { args = startList(new SqlIntervalQualifier(unit, null, getPos())); } &lt;FROM&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } &lt;RPAREN&gt; { return SqlStdOperatorTable.EXTRACT.createCall(s.end(this), args); } | &lt;POSITION&gt; { s = span(); } &lt;LPAREN&gt; FIXME jvs 31-Aug-2006: FRG-192: This should be Expression(ExprContext.ACCEPT_SUB_QUERY), but that doesn't work because it matches the other kind of IN. e = AtomicRowExpression() { args = startList(e); } &lt;IN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e);} [ &lt;FROM&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } ] &lt;RPAREN&gt; { return SqlStdOperatorTable.POSITION.createCall(s.end(this), args); } | &lt;CONVERT&gt; { s = span(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); } &lt;USING&gt; name = SimpleIdentifier() { args.add(name); } &lt;RPAREN&gt; { return SqlStdOperatorTable.CONVERT.createCall(s.end(this), args); } | &lt;TRANSLATE&gt; { s = span(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); } ( &lt;USING&gt; name = SimpleIdentifier() { args.add(name); } &lt;RPAREN&gt; { return SqlStdOperatorTable.TRANSLATE.createCall(s.end(this), args); } | ( &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } ) &lt;RPAREN&gt; { return SqlLibraryOperators.TRANSLATE3.createCall(s.end(this), args); } ) | &lt;OVERLAY&gt; { s = span(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); } &lt;PLACING&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } &lt;FROM&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } [ &lt;FOR&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } ] &lt;RPAREN&gt; { return SqlStdOperatorTable.OVERLAY.createCall(s.end(this), args); } | &lt;FLOOR&gt; { s = span(); } e = FloorCeilOptions(s, true) { return e; } | ( &lt;CEIL&gt; | &lt;CEILING&gt;) { s = span(); } e = FloorCeilOptions(s, false) { return e; } | &lt;SUBSTRING&gt; { s = span(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); } ( &lt;FROM&gt; | &lt;COMMA&gt;) e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } [ (&lt;FOR&gt; | &lt;COMMA&gt;) e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } ] &lt;RPAREN&gt; { return SqlStdOperatorTable.SUBSTRING.createCall( s.end(this), args); } | &lt;TRIM&gt; { SqlLiteral flag = null; SqlNode trimChars = null; s = span(); } &lt;LPAREN&gt; [ LOOKAHEAD(2) [ &lt;BOTH&gt; { s.add(this); flag = SqlTrimFunction.Flag.BOTH.symbol(getPos()); } | &lt;TRAILING&gt; { s.add(this); flag = SqlTrimFunction.Flag.TRAILING.symbol(getPos()); } | &lt;LEADING&gt; { s.add(this); flag = SqlTrimFunction.Flag.LEADING.symbol(getPos()); } ] [ trimChars = Expression(ExprContext.ACCEPT_SUB_QUERY) ] ( &lt;FROM&gt; { if (null == flag &amp;&amp; null == trimChars) { throw SqlUtil.newContextException(getPos(), RESOURCE.illegalFromEmpty()); } } | &lt;RPAREN&gt; { This is to handle the case of TRIM(x) (FRG-191). if (flag == null) { flag = SqlTrimFunction.Flag.BOTH.symbol(SqlParserPos.ZERO); } args = startList(flag); args.add(null); no trim chars args.add(trimChars); reinterpret trimChars as source return SqlStdOperatorTable.TRIM.createCall(s.end(this), args); } ) ] e = Expression(ExprContext.ACCEPT_SUB_QUERY) { if (flag == null) { flag = SqlTrimFunction.Flag.BOTH.symbol(SqlParserPos.ZERO); } args = startList(flag); args.add(trimChars); args.add(e); } &lt;RPAREN&gt; { return SqlStdOperatorTable.TRIM.createCall(s.end(this), args); } | node = TimestampAddFunctionCall() { return node; } | node = TimestampDiffFunctionCall() { return node; } | &lt;list (parser.builtinFunctionCallMethods!default.parser.builtinFunctionCallMethods) as method&gt; node = {method} { return node; } | &lt;list&gt; node = MatchRecognizeFunctionCall() { return node; } | node = JsonExistsFunctionCall() { return node; } | node = JsonValueFunctionCall() { return node; } | node = JsonQueryFunctionCall() { return node; } | node = JsonObjectFunctionCall() { return node; } | node = JsonObjectAggFunctionCall() { return node; } | node = JsonArrayFunctionCall() { return node; } | node = JsonArrayAggFunctionCall() { return node; } | node = GroupByWindowingCall() { return node; } ) } SqlJsonEncoding JsonRepresentation() : { } { &lt;JSON&gt; [ Encoding is currently ignored. LOOKAHEAD(2) &lt;ENCODING&gt; ( &lt;UTF8&gt; { return SqlJsonEncoding.UTF8; } | &lt;UTF16&gt; { return SqlJsonEncoding.UTF16; } | &lt;UTF32&gt; { return SqlJsonEncoding.UTF32; } ) ] { return SqlJsonEncoding.UTF8; } } void JsonInputClause() : { } { &lt;FORMAT&gt; JsonRepresentation() } SqlDataTypeSpec JsonReturningClause() : { SqlDataTypeSpec dt; } { &lt;RETURNING&gt; dt = DataType() { return dt; } } SqlDataTypeSpec JsonOutputClause() : { SqlDataTypeSpec dataType; } { dataType = JsonReturningClause() [ &lt;FORMAT&gt; JsonRepresentation() ] { return dataType; } } SqlNode JsonPathSpec() : { SqlNode e; } { e = StringLiteral() { return e; } } List&lt;SqlNode&gt; JsonApiCommonSyntax() : { SqlNode e; List&lt;SqlNode&gt; args = new ArrayList&lt;SqlNode&gt;(); } { e = Expression(ExprContext.ACCEPT_NON_QUERY) { args.add(e); } ( &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { args.add(e); } ) [ We currently don't support JSON passing clause, leave the java code blocks no-op &lt;PASSING&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { no-op } &lt;AS&gt; e = SimpleIdentifier() { no-op } ( &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { no-op } &lt;AS&gt; e = SimpleIdentifier() { no-op } ) ] { return args; } } SqlJsonExistsErrorBehavior JsonExistsErrorBehavior() : { } { &lt;TRUE&gt; { return SqlJsonExistsErrorBehavior.TRUE; } | &lt;FALSE&gt; { return SqlJsonExistsErrorBehavior.FALSE; } | &lt;UNKNOWN&gt; { return SqlJsonExistsErrorBehavior.UNKNOWN; } | &lt;ERROR&gt; { return SqlJsonExistsErrorBehavior.ERROR; } } SqlCall JsonExistsFunctionCall() : { List&lt;SqlNode&gt; args = new ArrayList&lt;SqlNode&gt;(); List&lt;SqlNode&gt; commonSyntax; final Span span; SqlJsonExistsErrorBehavior errorBehavior; } { &lt;JSON_EXISTS&gt; { span = span(); } &lt;LPAREN&gt; commonSyntax = JsonApiCommonSyntax() { args.addAll(commonSyntax); } [ errorBehavior = JsonExistsErrorBehavior() { args.add(errorBehavior.symbol(getPos())); } &lt;ON&gt; &lt;ERROR&gt; ] &lt;RPAREN&gt; { return SqlStdOperatorTable.JSON_EXISTS.createCall(span.end(this), args); } } List&lt;SqlNode&gt; JsonValueEmptyOrErrorBehavior() : { final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); final SqlNode e; } { ( &lt;ERROR&gt; { list.add(SqlJsonValueEmptyOrErrorBehavior.ERROR.symbol(getPos())); } | &lt;NULL&gt; { list.add(SqlJsonValueEmptyOrErrorBehavior.NULL.symbol(getPos())); } | &lt;DEFAULT_&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { list.add(SqlJsonValueEmptyOrErrorBehavior.DEFAULT.symbol(getPos())); list.add(e); } ) &lt;ON&gt; ( &lt;EMPTY&gt; { list.add(SqlJsonEmptyOrError.EMPTY.symbol(getPos())); } | &lt;ERROR&gt; { list.add(SqlJsonEmptyOrError.ERROR.symbol(getPos())); } ) { return list; } } SqlCall JsonValueFunctionCall() : { final List&lt;SqlNode&gt; args = new ArrayList&lt;SqlNode&gt;(7); SqlNode e; List&lt;SqlNode&gt; commonSyntax; final Span span; List&lt;SqlNode&gt; behavior; } { &lt;JSON_VALUE&gt; { span = span(); } &lt;LPAREN&gt; commonSyntax = JsonApiCommonSyntax() { args.addAll(commonSyntax); } [ e = JsonReturningClause() { args.add(SqlJsonValueReturning.RETURNING.symbol(getPos())); args.add(e); } ] ( behavior = JsonValueEmptyOrErrorBehavior() { args.addAll(behavior); } ) &lt;RPAREN&gt; { return SqlStdOperatorTable.JSON_VALUE.createCall(span.end(this), args); } } List&lt;SqlNode&gt; JsonQueryEmptyOrErrorBehavior() : { final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); SqlNode e; } { ( &lt;ERROR&gt; { list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.ERROR, getPos())); } | &lt;NULL&gt; { list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.NULL, getPos())); } | LOOKAHEAD(2) &lt;EMPTY&gt; &lt;ARRAY&gt; { list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.EMPTY_ARRAY, getPos())); } | &lt;EMPTY&gt; &lt;OBJECT&gt; { list.add(SqlLiteral.createSymbol(SqlJsonQueryEmptyOrErrorBehavior.EMPTY_OBJECT, getPos())); } ) &lt;ON&gt; ( &lt;EMPTY&gt; { list.add(SqlLiteral.createSymbol(SqlJsonEmptyOrError.EMPTY, getPos())); } | &lt;ERROR&gt; { list.add(SqlLiteral.createSymbol(SqlJsonEmptyOrError.ERROR, getPos())); } ) { return list; } } SqlNode JsonQueryWrapperBehavior() : { SqlNode e; } { &lt;WITHOUT&gt; [&lt;ARRAY&gt;] { return SqlLiteral.createSymbol(SqlJsonQueryWrapperBehavior.WITHOUT_ARRAY, getPos()); } | LOOKAHEAD(2) &lt;WITH&gt; &lt;CONDITIONAL&gt; [&lt;ARRAY&gt;] { return SqlLiteral.createSymbol(SqlJsonQueryWrapperBehavior.WITH_CONDITIONAL_ARRAY, getPos()); } | &lt;WITH&gt; [&lt;UNCONDITIONAL&gt;] [&lt;ARRAY&gt;] { return SqlLiteral.createSymbol(SqlJsonQueryWrapperBehavior.WITH_UNCONDITIONAL_ARRAY, getPos()); } } SqlCall JsonQueryFunctionCall() : { final SqlNode[] args = new SqlNode[5]; SqlNode e; List&lt;SqlNode&gt; commonSyntax; final Span span; List&lt;SqlNode&gt; behavior; } { &lt;JSON_QUERY&gt; { span = span(); } &lt;LPAREN&gt; commonSyntax = JsonApiCommonSyntax() { args[0] = commonSyntax.get(0); args[1] = commonSyntax.get(1); } [ e = JsonQueryWrapperBehavior() &lt;WRAPPER&gt; { args[2] = e; } ] ( behavior = JsonQueryEmptyOrErrorBehavior() { final SqlJsonEmptyOrError symbol = ((SqlLiteral) behavior.get(1)).getValueAs(SqlJsonEmptyOrError.class); switch (symbol) { case EMPTY: args[3] = behavior.get(0); break; case ERROR: args[4] = behavior.get(0); break; } } ) &lt;RPAREN&gt; { return SqlStdOperatorTable.JSON_QUERY.createCall(span.end(this), args); } } SqlNode JsonName() : { final SqlNode e; } { e = Expression(ExprContext.ACCEPT_NON_QUERY) { return e; } } List&lt;SqlNode&gt; JsonNameAndValue() : { final List&lt;SqlNode&gt; list = new ArrayList&lt;SqlNode&gt;(); SqlNode e; boolean kvMode = false; } { [ LOOKAHEAD(2, &lt;KEY&gt; JsonName()) &lt;KEY&gt; { kvMode = true; } ] e = JsonName() { list.add(e); } ( &lt;VALUE&gt; | &lt;COLON&gt; { if (kvMode) { throw SqlUtil.newContextException(getPos(), RESOURCE.illegalColon()); } } ) e = Expression(ExprContext.ACCEPT_NON_QUERY) { list.add(e); } { return list; } } SqlNode JsonConstructorNullClause() : { } { &lt;NULL&gt; &lt;ON&gt; &lt;NULL&gt; { return SqlLiteral.createSymbol(SqlJsonConstructorNullClause.NULL_ON_NULL, getPos()); } | &lt;ABSENT&gt; &lt;ON&gt; &lt;NULL&gt; { return SqlLiteral.createSymbol(SqlJsonConstructorNullClause.ABSENT_ON_NULL, getPos()); } } SqlCall JsonObjectFunctionCall() : { final List&lt;SqlNode&gt; nvArgs = new ArrayList&lt;SqlNode&gt;(); final SqlNode[] otherArgs = new SqlNode[1]; SqlNode e; List&lt;SqlNode&gt; list; final Span span; } { &lt;JSON_OBJECT&gt; { span = span(); } &lt;LPAREN&gt; [ LOOKAHEAD(2) list = JsonNameAndValue() { nvArgs.addAll(list); } ( &lt;COMMA&gt; list = JsonNameAndValue() { nvArgs.addAll(list); } ) ] [ e = JsonConstructorNullClause() { otherArgs[0] = e; } ] &lt;RPAREN&gt; { final List&lt;SqlNode&gt; args = new ArrayList(); args.addAll(Arrays.asList(otherArgs)); args.addAll(nvArgs); return SqlStdOperatorTable.JSON_OBJECT.createCall(span.end(this), args); } } SqlCall JsonObjectAggFunctionCall() : { final SqlNode[] args = new SqlNode[2]; List&lt;SqlNode&gt; list; final Span span; SqlJsonConstructorNullClause nullClause = SqlJsonConstructorNullClause.NULL_ON_NULL; final SqlNode e; } { &lt;JSON_OBJECTAGG&gt; { span = span(); } &lt;LPAREN&gt; list = JsonNameAndValue() { args[0] = list.get(0); args[1] = list.get(1); } [ e = JsonConstructorNullClause() { nullClause = (SqlJsonConstructorNullClause) ((SqlLiteral) e).getValue(); } ] &lt;RPAREN&gt; { return SqlStdOperatorTable.JSON_OBJECTAGG.with(nullClause) .createCall(span.end(this), args); } } SqlCall JsonArrayFunctionCall() : { final List&lt;SqlNode&gt; elements = new ArrayList&lt;SqlNode&gt;(); final SqlNode[] otherArgs = new SqlNode[1]; SqlNode e; final Span span; } { &lt;JSON_ARRAY&gt; { span = span(); } &lt;LPAREN&gt; [ LOOKAHEAD(2) e = Expression(ExprContext.ACCEPT_NON_QUERY) { elements.add(e); } ( &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { elements.add(e); } ) ] [ e = JsonConstructorNullClause() { otherArgs[0] = e; } ] &lt;RPAREN&gt; { final List&lt;SqlNode&gt; args = new ArrayList(); args.addAll(Arrays.asList(otherArgs)); args.addAll(elements); return SqlStdOperatorTable.JSON_ARRAY.createCall(span.end(this), args); } } SqlNodeList JsonArrayAggOrderByClause() : { final SqlNodeList orderList; } { ( orderList = OrderBy(true) | { orderList = null; } ) { return orderList; } } SqlCall JsonArrayAggFunctionCall() : { final SqlNode valueExpr; SqlNodeList orderList = null; List&lt;SqlNode&gt; list; final Span span; SqlJsonConstructorNullClause nullClause = SqlJsonConstructorNullClause.ABSENT_ON_NULL; SqlNode e = null; final SqlNode aggCall; } { &lt;JSON_ARRAYAGG&gt; { span = span(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_NON_QUERY) { valueExpr = e; } orderList = JsonArrayAggOrderByClause() [ e = JsonConstructorNullClause() { nullClause = (SqlJsonConstructorNullClause) ((SqlLiteral) e).getValue(); } ] &lt;RPAREN&gt; { aggCall = SqlStdOperatorTable.JSON_ARRAYAGG.with(nullClause) .createCall(span.end(this), valueExpr, orderList); } [ e = withinGroup(aggCall) { if (orderList != null) { throw SqlUtil.newContextException(span.pos().plus(e.getParserPosition()), RESOURCE.ambiguousSortOrderInJsonArrayAggFunc()); } return (SqlCall) e; } ] { if (orderList == null) { return SqlStdOperatorTable.JSON_ARRAYAGG.with(nullClause) .createCall(span.end(this), valueExpr); } return SqlStdOperatorTable.JSON_ARRAYAGG.with(nullClause) .createCall(span.end(this), valueExpr, orderList); } } Parses a call to TIMESTAMPADD. SqlCall TimestampAddFunctionCall() : { List&lt;SqlNode&gt; args; SqlNode e; final Span s; TimeUnit interval; SqlNode node; } { &lt;TIMESTAMPADD&gt; { s = span(); } &lt;LPAREN&gt; interval = TimestampInterval() { args = startList(SqlLiteral.createSymbol(interval, getPos())); } &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } &lt;RPAREN&gt; { return SqlStdOperatorTable.TIMESTAMP_ADD.createCall( s.end(this), args); } } Parses a call to TIMESTAMPDIFF. SqlCall TimestampDiffFunctionCall() : { List&lt;SqlNode&gt; args; SqlNode e; final Span s; TimeUnit interval; SqlNode node; } { &lt;TIMESTAMPDIFF&gt; { s = span(); } &lt;LPAREN&gt; interval = TimestampInterval() { args = startList(SqlLiteral.createSymbol(interval, getPos())); } &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } &lt;COMMA&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); } &lt;RPAREN&gt; { return SqlStdOperatorTable.TIMESTAMP_DIFF.createCall( s.end(this), args); } } Parses a call to a grouping function inside the GROUP BY clause, for example {@code TUMBLE(rowtime, INTERVAL '1' MINUTE)}. SqlCall GroupByWindowingCall(): { final Span s; final List&lt;SqlNode&gt; args; final SqlOperator op; } { ( &lt;TUMBLE&gt; { op = SqlStdOperatorTable.TUMBLE_OLD; } | &lt;HOP&gt; { op = SqlStdOperatorTable.HOP_OLD; } | &lt;SESSION&gt; { op = SqlStdOperatorTable.SESSION_OLD; } ) { s = span(); } args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) { return op.createCall(s.end(this), args); } } SqlCall MatchRecognizeFunctionCall() : { final SqlCall func; final Span s; } { ( &lt;CLASSIFIER&gt; { s = span(); } &lt;LPAREN&gt; &lt;RPAREN&gt; { func = SqlStdOperatorTable.CLASSIFIER.createCall(s.end(this)); } | &lt;MATCH_NUMBER&gt; { s = span(); } &lt;LPAREN&gt; &lt;RPAREN&gt; { func = SqlStdOperatorTable.MATCH_NUMBER.createCall(s.end(this)); } | LOOKAHEAD(3) func = MatchRecognizeNavigationLogical() | LOOKAHEAD(2) func = MatchRecognizeNavigationPhysical() | func = MatchRecognizeCallWithModifier() ) { return func; } } SqlCall MatchRecognizeCallWithModifier() : { final Span s; final SqlOperator runningOp; final SqlNode func; } { ( &lt;RUNNING&gt; { runningOp = SqlStdOperatorTable.RUNNING; } | &lt;FINAL&gt; { runningOp = SqlStdOperatorTable.FINAL; } ) { s = span(); } func = NamedFunctionCall() { return runningOp.createCall(s.end(func), func); } } SqlCall MatchRecognizeNavigationLogical() : { final Span s = Span.of(); SqlCall func; final SqlOperator funcOp; final SqlOperator runningOp; SqlNode arg0; SqlNode arg1 = SqlLiteral.createExactNumeric(&quot;0&quot;, SqlParserPos.ZERO); } { ( &lt;RUNNING&gt; { runningOp = SqlStdOperatorTable.RUNNING; s.add(this); } | &lt;FINAL&gt; { runningOp = SqlStdOperatorTable.FINAL; s.add(this); } | { runningOp = null; } ) ( &lt;FIRST&gt; { funcOp = SqlStdOperatorTable.FIRST; } | &lt;LAST&gt; { funcOp = SqlStdOperatorTable.LAST; } ) { s.add(this); } &lt;LPAREN&gt; arg0 = Expression(ExprContext.ACCEPT_SUB_QUERY) [ &lt;COMMA&gt; arg1 = NumericLiteral() ] &lt;RPAREN&gt; { func = funcOp.createCall(s.end(this), arg0, arg1); if (runningOp != null) { return runningOp.createCall(s.end(this), func); } else { return func; } } } SqlCall MatchRecognizeNavigationPhysical() : { final Span s; SqlCall func; SqlOperator funcOp; SqlNode arg0; SqlNode arg1 = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO); } { ( &lt;PREV&gt; { funcOp = SqlStdOperatorTable.PREV; } | &lt;NEXT&gt; { funcOp = SqlStdOperatorTable.NEXT; } ) { s = span(); } &lt;LPAREN&gt; arg0 = Expression(ExprContext.ACCEPT_SUB_QUERY) [ &lt;COMMA&gt; arg1 = NumericLiteral() ] &lt;RPAREN&gt; { return funcOp.createCall(s.end(this), arg0, arg1); } } SqlCall withinGroup(SqlNode arg) : { final Span withinGroupSpan; final SqlNodeList orderList; } { &lt;WITHIN&gt; { withinGroupSpan = span(); } &lt;GROUP&gt; &lt;LPAREN&gt; orderList = OrderBy(true) &lt;RPAREN&gt; { return SqlStdOperatorTable.WITHIN_GROUP.createCall( withinGroupSpan.end(this), arg, orderList); } } SqlCall nullTreatment(SqlCall arg) : { final Span span; } { ( &lt;IGNORE&gt; { span = span(); } &lt;NULLS&gt; { return SqlStdOperatorTable.IGNORE_NULLS.createCall( span.end(this), arg); } | &lt;RESPECT&gt; { span = span(); } &lt;NULLS&gt; { return SqlStdOperatorTable.RESPECT_NULLS.createCall( span.end(this), arg); } ) } Parses a call to a named function (could be a builtin with regular syntax, or else a UDF). &lt;p&gt;NOTE: every UDF has two names: an &lt;em&gt;invocation name&lt;em&gt; and a &lt;em&gt;specific name&lt;em&gt;. Normally, function calls are resolved via overload resolution and invocation names. The SPECIFIC prefix allows overload resolution to be bypassed. Note that usage of the SPECIFIC prefix in queries is non-standard; it is used internally by Farrago, e.g. in stored view definitions to permanently bind references to a particular function after the overload resolution performed by view creation. &lt;p&gt;TODO jvs 25-Mar-2005: Once we have SQL-Flagger support, flag SPECIFIC as non-standard. SqlNode NamedFunctionCall() : { final SqlFunctionCategory funcType; final SqlIdentifier qualifiedName; final Span s; final List&lt;SqlNode&gt; args; SqlCall call; final Span filterSpan; final SqlNode filter; final SqlNode over; SqlLiteral quantifier = null; SqlNodeList orderList = null; final Span withinGroupSpan; } { ( &lt;SPECIFIC&gt; { funcType = SqlFunctionCategory.USER_DEFINED_SPECIFIC_FUNCTION; } | { funcType = SqlFunctionCategory.USER_DEFINED_FUNCTION; } ) qualifiedName = FunctionName() { s = span(); } ( LOOKAHEAD(2) &lt;LPAREN&gt; &lt;STAR&gt; { args = startList(SqlIdentifier.star(getPos())); } &lt;RPAREN&gt; | LOOKAHEAD(2) &lt;LPAREN&gt; &lt;RPAREN&gt; { args = Collections.emptyList(); } | args = FunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) { quantifier = (SqlLiteral) args.get(0); args.remove(0); } ) { call = createCall(qualifiedName, s.end(this), funcType, quantifier, args); } [ LOOKAHEAD(2) call = nullTreatment(call) ] [ call = withinGroup(call) ] [ &lt;FILTER&gt; { filterSpan = span(); } &lt;LPAREN&gt; &lt;WHERE&gt; filter = Expression(ExprContext.ACCEPT_SUB_QUERY) &lt;RPAREN&gt; { call = SqlStdOperatorTable.FILTER.createCall( filterSpan.end(this), call, filter); } ] [ &lt;OVER&gt; ( over = SimpleIdentifier() | over = WindowSpecification() ) { call = SqlStdOperatorTable.OVER.createCall(s.end(over), call, over); } ] { return call; } } Parse FloorCeil function parameters SqlNode StandardFloorCeilOptions(Span s, boolean floorFlag) : { SqlNode e; final List&lt;SqlNode&gt; args; TimeUnit unit; SqlCall function; final Span s1; } { &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); } ( &lt;TO&gt; unit = TimeUnit() { args.add(new SqlIntervalQualifier(unit, null, getPos())); } )? &lt;RPAREN&gt; { SqlOperator op = floorFlag ? SqlStdOperatorTable.FLOOR : SqlStdOperatorTable.CEIL; function = op.createCall(s.end(this), args); } ( &lt;OVER&gt; { s1 = span(); } ( e = SimpleIdentifier() | e = WindowSpecification() ) { return SqlStdOperatorTable.OVER.createCall(s1.end(this), function, e); } | { return function; } ) } Parses the name of a JDBC function that is a token but is not reserved. String NonReservedJdbcFunctionName() : { } { ( &lt;SUBSTRING&gt; ) { return unquotedIdentifier(); } } Parses the name of a function (either a compound identifier or a reserved word which can be used as a function name). SqlIdentifier FunctionName() : { SqlIdentifier qualifiedName; } { ( qualifiedName = CompoundIdentifier() | qualifiedName = ReservedFunctionName() ) { return qualifiedName; } } Parses a reserved word which is used as the name of a function. SqlIdentifier ReservedFunctionName() : { } { ( &lt;ABS&gt; | &lt;AVG&gt; | &lt;CARDINALITY&gt; | &lt;CEILING&gt; | &lt;CHAR_LENGTH&gt; | &lt;CHARACTER_LENGTH&gt; | &lt;COALESCE&gt; | &lt;COLLECT&gt; | &lt;COVAR_POP&gt; | &lt;COVAR_SAMP&gt; | &lt;CUME_DIST&gt; | &lt;COUNT&gt; | &lt;CURRENT_DATE&gt; | &lt;CURRENT_TIME&gt; | &lt;CURRENT_TIMESTAMP&gt; | &lt;DENSE_RANK&gt; | &lt;ELEMENT&gt; | &lt;EVERY&gt; | &lt;EXP&gt; | &lt;FIRST_VALUE&gt; | &lt;FLOOR&gt; | &lt;FUSION&gt; | &lt;INTERSECTION&gt; | &lt;GROUPING&gt; | &lt;HOUR&gt; | &lt;LAG&gt; | &lt;LEAD&gt; | &lt;LEFT&gt; | &lt;LAST_VALUE&gt; | &lt;LN&gt; | &lt;LOCALTIME&gt; | &lt;LOCALTIMESTAMP&gt; | &lt;LOWER&gt; | &lt;MAX&gt; | &lt;MIN&gt; | &lt;MINUTE&gt; | &lt;MOD&gt; | &lt;MONTH&gt; | &lt;NTH_VALUE&gt; | &lt;NTILE&gt; | &lt;NULLIF&gt; | &lt;OCTET_LENGTH&gt; | &lt;PERCENT_RANK&gt; | &lt;POWER&gt; | &lt;RANK&gt; | &lt;REGR_COUNT&gt; | &lt;REGR_SXX&gt; | &lt;REGR_SYY&gt; | &lt;RIGHT&gt; | &lt;ROW_NUMBER&gt; | &lt;SECOND&gt; | &lt;SOME&gt; | &lt;SQRT&gt; | &lt;STDDEV_POP&gt; | &lt;STDDEV_SAMP&gt; | &lt;SUM&gt; | &lt;UPPER&gt; | &lt;TRUNCATE&gt; | &lt;USER&gt; | &lt;VAR_POP&gt; | &lt;VAR_SAMP&gt; | &lt;YEAR&gt; ) { return new SqlIdentifier(unquotedIdentifier(), getPos()); } } SqlIdentifier ContextVariable() : { } { ( &lt;CURRENT_CATALOG&gt; | &lt;CURRENT_DATE&gt; | &lt;CURRENT_DEFAULT_TRANSFORM_GROUP&gt; | &lt;CURRENT_PATH&gt; | &lt;CURRENT_ROLE&gt; | &lt;CURRENT_SCHEMA&gt; | &lt;CURRENT_TIME&gt; | &lt;CURRENT_TIMESTAMP&gt; | &lt;CURRENT_USER&gt; | &lt;LOCALTIME&gt; | &lt;LOCALTIMESTAMP&gt; | &lt;SESSION_USER&gt; | &lt;SYSTEM_USER&gt; | &lt;USER&gt; ) { return new SqlIdentifier(unquotedIdentifier(), getPos()); } } Parses a function call expression with JDBC syntax. SqlNode JdbcFunctionCall() : { String name; SqlIdentifier id; SqlNode e; SqlLiteral tl; SqlNodeList args; SqlCall call; final Span s, s1; } { &lt;LBRACE_FN&gt; { s = span(); } ( LOOKAHEAD(1) call = TimestampAddFunctionCall() { name = call.getOperator().getName(); args = new SqlNodeList(call.getOperandList(), getPos()); } | LOOKAHEAD(3) call = TimestampDiffFunctionCall() { name = call.getOperator().getName(); args = new SqlNodeList(call.getOperandList(), getPos()); } | &lt;CONVERT&gt; { name = unquotedIdentifier(); } &lt;LPAREN&gt; e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = new SqlNodeList(getPos()); args.add(e); } &lt;COMMA&gt; tl = JdbcOdbcDataType() { args.add(tl); } &lt;RPAREN&gt; | ( INSERT is a reserved word, but we need to handle {fn insert} Similarly LEFT, RIGHT, TRUNCATE LOOKAHEAD(1) ( &lt;INSERT&gt; | &lt;LEFT&gt; | &lt;RIGHT&gt; | &lt;TRUNCATE&gt; ) { name = unquotedIdentifier(); } | For cases like {fn power(1,2)} and {fn lower('a')} id = ReservedFunctionName() { name = id.getSimple(); } | For cases like {fn substring('foo', 1,2)} name = NonReservedJdbcFunctionName() | name = Identifier() ) ( LOOKAHEAD(2) &lt;LPAREN&gt; &lt;STAR&gt; { s1 = span(); } &lt;RPAREN&gt; { args = new SqlNodeList(s1.pos()); args.add(SqlIdentifier.star(s1.pos())); } | LOOKAHEAD(2) &lt;LPAREN&gt; &lt;RPAREN&gt; { args = SqlNodeList.EMPTY; } | args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUB_QUERY) ) ) &lt;RBRACE&gt; { return new SqlJdbcFunctionCall(name).createCall(s.end(this), args.getList()); } } Parses a binary query operator like UNION. SqlBinaryOperator BinaryQueryOperator() : { } { If both the ALL or DISTINCT keywords are missing, DISTINCT is implicit. ( &lt;UNION&gt; ( &lt;ALL&gt; { return SqlStdOperatorTable.UNION_ALL; } | &lt;DISTINCT&gt; { return SqlStdOperatorTable.UNION; } | { return SqlStdOperatorTable.UNION; } ) | &lt;INTERSECT&gt; ( &lt;ALL&gt; { return SqlStdOperatorTable.INTERSECT_ALL; } | &lt;DISTINCT&gt; { return SqlStdOperatorTable.INTERSECT; } | { return SqlStdOperatorTable.INTERSECT; } ) | ( &lt;EXCEPT&gt; | &lt;SET_MINUS&gt; { if (!this.conformance.isMinusAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.minusNotAllowed()); } } ) ( &lt;ALL&gt; { return SqlStdOperatorTable.EXCEPT_ALL; } | &lt;DISTINCT&gt; { return SqlStdOperatorTable.EXCEPT; } | { return SqlStdOperatorTable.EXCEPT; } ) ) } Parses a binary multiset operator. SqlBinaryOperator BinaryMultisetOperator() : { } { If both the ALL or DISTINCT keywords are missing, DISTINCT is implicit &lt;MULTISET&gt; ( &lt;UNION&gt; [ &lt;ALL&gt; | &lt;DISTINCT&gt; { return SqlStdOperatorTable.MULTISET_UNION_DISTINCT; } ] { return SqlStdOperatorTable.MULTISET_UNION; } | &lt;INTERSECT&gt; [ &lt;ALL&gt; | &lt;DISTINCT&gt; { return SqlStdOperatorTable.MULTISET_INTERSECT_DISTINCT; } ] { return SqlStdOperatorTable.MULTISET_INTERSECT; } | &lt;EXCEPT&gt; [ &lt;ALL&gt; | &lt;DISTINCT&gt; { return SqlStdOperatorTable.MULTISET_EXCEPT_DISTINCT; } ] { return SqlStdOperatorTable.MULTISET_EXCEPT; } ) } Parses a binary row operator like AND. SqlBinaryOperator BinaryRowOperator() : { SqlBinaryOperator op; } { &lt;IN&gt; is handled as a special case &lt;EQ&gt; { return SqlStdOperatorTable.EQUALS; } | &lt;GT&gt; { return SqlStdOperatorTable.GREATER_THAN; } | &lt;LT&gt; { return SqlStdOperatorTable.LESS_THAN; } | &lt;LE&gt; { return SqlStdOperatorTable.LESS_THAN_OR_EQUAL; } | &lt;GE&gt; { return SqlStdOperatorTable.GREATER_THAN_OR_EQUAL; } | &lt;NE&gt; { return SqlStdOperatorTable.NOT_EQUALS; } | &lt;NE2&gt; { if (!this.conformance.isBangEqualAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.bangEqualNotAllowed()); } return SqlStdOperatorTable.NOT_EQUALS; } | &lt;PLUS&gt; { return SqlStdOperatorTable.PLUS; } | &lt;MINUS&gt; { return SqlStdOperatorTable.MINUS; } | &lt;STAR&gt; { return SqlStdOperatorTable.MULTIPLY; } | &lt;SLASH&gt; { return SqlStdOperatorTable.DIVIDE; } | &lt;PERCENT_REMAINDER&gt; { if (!this.conformance.isPercentRemainderAllowed()) { throw SqlUtil.newContextException(getPos(), RESOURCE.percentRemainderNotAllowed()); } return SqlStdOperatorTable.PERCENT_REMAINDER; } | &lt;CONCAT&gt; { return SqlStdOperatorTable.CONCAT; } | &lt;AND&gt; { return SqlStdOperatorTable.AND; } | &lt;OR&gt; { return SqlStdOperatorTable.OR; } | LOOKAHEAD(2) &lt;IS&gt; &lt;DISTINCT&gt; &lt;FROM&gt; { return SqlStdOperatorTable.IS_DISTINCT_FROM; } | &lt;IS&gt; &lt;NOT&gt; &lt;DISTINCT&gt; &lt;FROM&gt; { return SqlStdOperatorTable.IS_NOT_DISTINCT_FROM; } | &lt;MEMBER&gt; &lt;OF&gt; { return SqlStdOperatorTable.MEMBER_OF; } | LOOKAHEAD(2) &lt;SUBMULTISET&gt; &lt;OF&gt; { return SqlStdOperatorTable.SUBMULTISET_OF; } | &lt;NOT&gt; &lt;SUBMULTISET&gt; &lt;OF&gt; { return SqlStdOperatorTable.NOT_SUBMULTISET_OF; } | &lt;CONTAINS&gt; { return SqlStdOperatorTable.CONTAINS; } | &lt;OVERLAPS&gt; { return SqlStdOperatorTable.OVERLAPS; } | &lt;EQUALS&gt; { return SqlStdOperatorTable.PERIOD_EQUALS; } | &lt;PRECEDES&gt; { return SqlStdOperatorTable.PRECEDES; } | &lt;SUCCEEDS&gt; { return SqlStdOperatorTable.SUCCEEDS; } | LOOKAHEAD(2) &lt;IMMEDIATELY&gt; &lt;PRECEDES&gt; { return SqlStdOperatorTable.IMMEDIATELY_PRECEDES; } | &lt;IMMEDIATELY&gt; &lt;SUCCEEDS&gt; { return SqlStdOperatorTable.IMMEDIATELY_SUCCEEDS; } | op = BinaryMultisetOperator() { return op; } } Parses a prefix row operator like NOT. SqlPrefixOperator PrefixRowOperator() : {} { &lt;PLUS&gt; { return SqlStdOperatorTable.UNARY_PLUS; } | &lt;MINUS&gt; { return SqlStdOperatorTable.UNARY_MINUS; } | &lt;NOT&gt; { return SqlStdOperatorTable.NOT; } | &lt;EXISTS&gt; { return SqlStdOperatorTable.EXISTS; } } Parses a postfix row operator like IS NOT NULL. SqlPostfixOperator PostfixRowOperator() : {} { &lt;IS&gt; ( &lt;A&gt; &lt;SET&gt; { return SqlStdOperatorTable.IS_A_SET; } | &lt;NOT&gt; ( &lt;NULL&gt; { return SqlStdOperatorTable.IS_NOT_NULL; } | &lt;TRUE&gt; { return SqlStdOperatorTable.IS_NOT_TRUE; } | &lt;FALSE&gt; { return SqlStdOperatorTable.IS_NOT_FALSE; } | &lt;UNKNOWN&gt; { return SqlStdOperatorTable.IS_NOT_UNKNOWN; } | &lt;A&gt; &lt;SET&gt; { return SqlStdOperatorTable.IS_NOT_A_SET; } | &lt;EMPTY&gt; { return SqlStdOperatorTable.IS_NOT_EMPTY; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;VALUE&gt; { return SqlStdOperatorTable.IS_NOT_JSON_VALUE; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;OBJECT&gt; { return SqlStdOperatorTable.IS_NOT_JSON_OBJECT; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;ARRAY&gt; { return SqlStdOperatorTable.IS_NOT_JSON_ARRAY; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;SCALAR&gt; { return SqlStdOperatorTable.IS_NOT_JSON_SCALAR; } | &lt;JSON&gt; { return SqlStdOperatorTable.IS_NOT_JSON_VALUE; } ) | ( &lt;NULL&gt; { return SqlStdOperatorTable.IS_NULL; } | &lt;TRUE&gt; { return SqlStdOperatorTable.IS_TRUE; } | &lt;FALSE&gt; { return SqlStdOperatorTable.IS_FALSE; } | &lt;UNKNOWN&gt; { return SqlStdOperatorTable.IS_UNKNOWN; } | &lt;EMPTY&gt; { return SqlStdOperatorTable.IS_EMPTY; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;VALUE&gt; { return SqlStdOperatorTable.IS_JSON_VALUE; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;OBJECT&gt; { return SqlStdOperatorTable.IS_JSON_OBJECT; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;ARRAY&gt; { return SqlStdOperatorTable.IS_JSON_ARRAY; } | LOOKAHEAD(2) &lt;JSON&gt; &lt;SCALAR&gt; { return SqlStdOperatorTable.IS_JSON_SCALAR; } | &lt;JSON&gt; { return SqlStdOperatorTable.IS_JSON_VALUE; } ) ) | &lt;FORMAT&gt; ( JsonRepresentation() { return SqlStdOperatorTable.JSON_VALUE_EXPRESSION; } ) } KEYWORDS: anything in this list is a reserved word unless it appears in the NonReservedKeyWord() production. &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; A: &quot;A&quot; &gt; | &lt; ABS: &quot;ABS&quot; &gt; | &lt; ABSENT: &quot;ABSENT&quot; &gt; | &lt; ABSOLUTE: &quot;ABSOLUTE&quot; &gt; | &lt; ACTION: &quot;ACTION&quot; &gt; | &lt; ADA: &quot;ADA&quot; &gt; | &lt; ADD: &quot;ADD&quot; &gt; | &lt; ADMIN: &quot;ADMIN&quot; &gt; | &lt; AFTER: &quot;AFTER&quot; &gt; | &lt; ALL: &quot;ALL&quot; &gt; | &lt; ALLOCATE: &quot;ALLOCATE&quot; &gt; | &lt; ALLOW: &quot;ALLOW&quot; &gt; | &lt; ALTER: &quot;ALTER&quot; &gt; | &lt; ALWAYS: &quot;ALWAYS&quot; &gt; | &lt; AND: &quot;AND&quot; &gt; | &lt; ANY: &quot;ANY&quot; &gt; | &lt; APPLY: &quot;APPLY&quot; &gt; | &lt; ARE: &quot;ARE&quot; &gt; | &lt; ARRAY: &quot;ARRAY&quot; &gt; | &lt; ARRAY_MAX_CARDINALITY: &quot;ARRAY_MAX_CARDINALITY&quot; &gt; | &lt; AS: &quot;AS&quot; &gt; | &lt; ASC: &quot;ASC&quot; &gt; | &lt; ASENSITIVE: &quot;ASENSITIVE&quot; &gt; | &lt; ASSERTION: &quot;ASSERTION&quot; &gt; | &lt; ASSIGNMENT: &quot;ASSIGNMENT&quot; &gt; | &lt; ASYMMETRIC: &quot;ASYMMETRIC&quot; &gt; | &lt; AT: &quot;AT&quot; &gt; | &lt; ATOMIC: &quot;ATOMIC&quot; &gt; | &lt; ATTRIBUTE: &quot;ATTRIBUTE&quot; &gt; | &lt; ATTRIBUTES: &quot;ATTRIBUTES&quot; &gt; | &lt; AUTHORIZATION: &quot;AUTHORIZATION&quot; &gt; | &lt; AVG: &quot;AVG&quot; &gt; | &lt; BEFORE: &quot;BEFORE&quot; &gt; | &lt; BEGIN: &quot;BEGIN&quot; &gt; | &lt; BEGIN_FRAME: &quot;BEGIN_FRAME&quot; &gt; | &lt; BEGIN_PARTITION: &quot;BEGIN_PARTITION&quot; &gt; | &lt; BERNOULLI: &quot;BERNOULLI&quot; &gt; | &lt; BETWEEN: &quot;BETWEEN&quot; &gt; | &lt; BIGINT: &quot;BIGINT&quot; &gt; | &lt; BINARY: &quot;BINARY&quot; &gt; | &lt; BIT: &quot;BIT&quot; &gt; | &lt; BLOB: &quot;BLOB&quot; &gt; | &lt; BOOLEAN: &quot;BOOLEAN&quot; &gt; | &lt; BOTH: &quot;BOTH&quot; &gt; | &lt; BREADTH: &quot;BREADTH&quot; &gt; | &lt; BY: &quot;BY&quot; &gt; | &lt; C: &quot;C&quot; &gt; | &lt; CALL: &quot;CALL&quot; &gt; | &lt; CALLED: &quot;CALLED&quot; &gt; | &lt; CARDINALITY: &quot;CARDINALITY&quot; &gt; | &lt; CASCADE: &quot;CASCADE&quot; &gt; | &lt; CASCADED: &quot;CASCADED&quot; &gt; | &lt; CASE: &quot;CASE&quot; &gt; | &lt; CAST: &quot;CAST&quot; &gt; | &lt; CATALOG: &quot;CATALOG&quot; &gt; | &lt; CATALOG_NAME: &quot;CATALOG_NAME&quot; &gt; | &lt; CEIL: &quot;CEIL&quot; &gt; | &lt; CEILING: &quot;CEILING&quot; &gt; | &lt; CENTURY: &quot;CENTURY&quot; &gt; | &lt; CHAIN: &quot;CHAIN&quot; &gt; | &lt; CHAR: &quot;CHAR&quot; &gt; | &lt; CHAR_LENGTH: &quot;CHAR_LENGTH&quot; &gt; | &lt; CHARACTER: &quot;CHARACTER&quot; &gt; | &lt; CHARACTER_LENGTH: &quot;CHARACTER_LENGTH&quot; &gt; | &lt; CHARACTER_SET_CATALOG: &quot;CHARACTER_SET_CATALOG&quot; &gt; | &lt; CHARACTER_SET_NAME: &quot;CHARACTER_SET_NAME&quot; &gt; | &lt; CHARACTER_SET_SCHEMA: &quot;CHARACTER_SET_SCHEMA&quot; &gt; | &lt; CHARACTERISTICS: &quot;CHARACTERISTICS&quot; &gt; | &lt; CHARACTERS: &quot;CHARACTERS&quot; &gt; | &lt; CHECK: &quot;CHECK&quot; &gt; | &lt; CLASSIFIER: &quot;CLASSIFIER&quot; &gt; | &lt; CLASS_ORIGIN: &quot;CLASS_ORIGIN&quot; &gt; | &lt; CLOB: &quot;CLOB&quot; &gt; | &lt; CLOSE: &quot;CLOSE&quot; &gt; | &lt; COALESCE: &quot;COALESCE&quot; &gt; | &lt; COBOL: &quot;COBOL&quot; &gt; | &lt; COLLATE: &quot;COLLATE&quot; &gt; | &lt; COLLATION: &quot;COLLATION&quot; &gt; | &lt; COLLATION_CATALOG: &quot;COLLATION_CATALOG&quot; &gt; | &lt; COLLATION_NAME: &quot;COLLATION_NAME&quot; &gt; | &lt; COLLATION_SCHEMA: &quot;COLLATION_SCHEMA&quot; &gt; | &lt; COLLECT: &quot;COLLECT&quot; &gt; | &lt; COLUMN: &quot;COLUMN&quot; &gt; | &lt; COLUMN_NAME: &quot;COLUMN_NAME&quot; &gt; | &lt; COMMAND_FUNCTION: &quot;COMMAND_FUNCTION&quot; &gt; | &lt; COMMAND_FUNCTION_CODE: &quot;COMMAND_FUNCTION_CODE&quot; &gt; | &lt; COMMIT: &quot;COMMIT&quot; &gt; | &lt; COMMITTED: &quot;COMMITTED&quot; &gt; | &lt; CONDITION: &quot;CONDITION&quot; &gt; | &lt; CONDITIONAL: &quot;CONDITIONAL&quot; &gt; | &lt; CONDITION_NUMBER: &quot;CONDITION_NUMBER&quot; &gt; | &lt; CONNECT: &quot;CONNECT&quot; &gt; | &lt; CONNECTION: &quot;CONNECTION&quot; &gt; | &lt; CONNECTION_NAME: &quot;CONNECTION_NAME&quot; &gt; | &lt; CONSTRAINT: &quot;CONSTRAINT&quot; &gt; | &lt; CONSTRAINT_CATALOG: &quot;CONSTRAINT_CATALOG&quot; &gt; | &lt; CONSTRAINT_NAME: &quot;CONSTRAINT_NAME&quot; &gt; | &lt; CONSTRAINT_SCHEMA: &quot;CONSTRAINT_SCHEMA&quot; &gt; | &lt; CONSTRAINTS: &quot;CONSTRAINTS&quot; &gt; | &lt; CONSTRUCTOR: &quot;CONSTRUCTOR&quot; &gt; | &lt; CONTAINS: &quot;CONTAINS&quot; &gt; | &lt; CONTINUE: &quot;CONTINUE&quot; &gt; | &lt; CONVERT: &quot;CONVERT&quot; &gt; | &lt; CORR: &quot;CORR&quot; &gt; | &lt; CORRESPONDING: &quot;CORRESPONDING&quot; &gt; | &lt; COUNT: &quot;COUNT&quot; &gt; | &lt; COVAR_POP: &quot;COVAR_POP&quot; &gt; | &lt; COVAR_SAMP: &quot;COVAR_SAMP&quot; &gt; | &lt; CREATE: &quot;CREATE&quot; &gt; | &lt; CROSS: &quot;CROSS&quot; &gt; | &lt; CUBE: &quot;CUBE&quot; &gt; | &lt; CUME_DIST: &quot;CUME_DIST&quot; &gt; | &lt; CURRENT: &quot;CURRENT&quot; &gt; | &lt; CURRENT_CATALOG: &quot;CURRENT_CATALOG&quot; &gt; | &lt; CURRENT_DATE: &quot;CURRENT_DATE&quot; &gt; | &lt; CURRENT_DEFAULT_TRANSFORM_GROUP: &quot;CURRENT_DEFAULT_TRANSFORM_GROUP&quot; &gt; | &lt; CURRENT_PATH: &quot;CURRENT_PATH&quot; &gt; | &lt; CURRENT_ROLE: &quot;CURRENT_ROLE&quot; &gt; | &lt; CURRENT_ROW: &quot;CURRENT_ROW&quot; &gt; | &lt; CURRENT_SCHEMA: &quot;CURRENT_SCHEMA&quot; &gt; | &lt; CURRENT_TIME: &quot;CURRENT_TIME&quot; &gt; | &lt; CURRENT_TIMESTAMP: &quot;CURRENT_TIMESTAMP&quot; &gt; | &lt; CURRENT_TRANSFORM_GROUP_FOR_TYPE: &quot;CURRENT_TRANSFORM_GROUP_FOR_TYPE&quot; &gt; | &lt; CURRENT_USER: &quot;CURRENT_USER&quot; &gt; | &lt; CURSOR: &quot;CURSOR&quot; &gt; | &lt; CURSOR_NAME: &quot;CURSOR_NAME&quot; &gt; | &lt; CYCLE: &quot;CYCLE&quot; &gt; | &lt; DATA: &quot;DATA&quot; &gt; | &lt; DATABASE: &quot;DATABASE&quot; &gt; | &lt; DATE: &quot;DATE&quot; &gt; | &lt; DATETIME_INTERVAL_CODE: &quot;DATETIME_INTERVAL_CODE&quot; &gt; | &lt; DATETIME_INTERVAL_PRECISION: &quot;DATETIME_INTERVAL_PRECISION&quot; &gt; | &lt; DAY: &quot;DAY&quot; &gt; | &lt; DAYS: &quot;DAYS&quot; &gt; | &lt; DEALLOCATE: &quot;DEALLOCATE&quot; &gt; | &lt; DEC: &quot;DEC&quot; &gt; | &lt; DECADE: &quot;DECADE&quot; &gt; | &lt; DECIMAL: &quot;DECIMAL&quot; &gt; | &lt; DECLARE: &quot;DECLARE&quot; &gt; | &lt; DEFAULT_: &quot;DEFAULT&quot; &gt; | &lt; DEFAULTS: &quot;DEFAULTS&quot; &gt; | &lt; DEFERRABLE: &quot;DEFERRABLE&quot; &gt; | &lt; DEFERRED: &quot;DEFERRED&quot; &gt; | &lt; DEFINE: &quot;DEFINE&quot; &gt; | &lt; DEFINED: &quot;DEFINED&quot; &gt; | &lt; DEFINER: &quot;DEFINER&quot; &gt; | &lt; DEGREE: &quot;DEGREE&quot; &gt; | &lt; DELETE: &quot;DELETE&quot; &gt; { beforeTableName(); } | &lt; DENSE_RANK: &quot;DENSE_RANK&quot; &gt; | &lt; DEPTH: &quot;DEPTH&quot; &gt; | &lt; DEREF: &quot;DEREF&quot; &gt; | &lt; DERIVED: &quot;DERIVED&quot; &gt; | &lt; DESC: &quot;DESC&quot; &gt; | &lt; DESCRIBE: &quot;DESCRIBE&quot; &gt; { beforeTableName(); } | &lt; DESCRIPTION: &quot;DESCRIPTION&quot; &gt; | &lt; DESCRIPTOR: &quot;DESCRIPTOR&quot; &gt; | &lt; DETERMINISTIC: &quot;DETERMINISTIC&quot; &gt; | &lt; DIAGNOSTICS: &quot;DIAGNOSTICS&quot; &gt; | &lt; DISALLOW: &quot;DISALLOW&quot; &gt; | &lt; DISCONNECT: &quot;DISCONNECT&quot; &gt; | &lt; DISPATCH: &quot;DISPATCH&quot; &gt; | &lt; DISTINCT: &quot;DISTINCT&quot; &gt; | &lt; DOMAIN: &quot;DOMAIN&quot; &gt; | &lt; DOUBLE: &quot;DOUBLE&quot; &gt; | &lt; DOW: &quot;DOW&quot; &gt; | &lt; DOY: &quot;DOY&quot; &gt; | &lt; DROP: &quot;DROP&quot; &gt; | &lt; DYNAMIC: &quot;DYNAMIC&quot; &gt; | &lt; DYNAMIC_FUNCTION: &quot;DYNAMIC_FUNCTION&quot; &gt; | &lt; DYNAMIC_FUNCTION_CODE: &quot;DYNAMIC_FUNCTION_CODE&quot; &gt; | &lt; EACH: &quot;EACH&quot; &gt; | &lt; ELEMENT: &quot;ELEMENT&quot; &gt; | &lt; ELSE: &quot;ELSE&quot; &gt; | &lt; EMPTY: &quot;EMPTY&quot; &gt; | &lt; ENCODING: &quot;ENCODING&quot;&gt; | &lt; END: &quot;END&quot; &gt; | &lt; END_EXEC: &quot;END-EXEC&quot; &gt; | &lt; END_FRAME: &quot;END_FRAME&quot; &gt; | &lt; END_PARTITION: &quot;END_PARTITION&quot; &gt; | &lt; EPOCH: &quot;EPOCH&quot; &gt; | &lt; EQUALS: &quot;EQUALS&quot; &gt; | &lt; ERROR: &quot;ERROR&quot; &gt; | &lt; ESCAPE: &quot;ESCAPE&quot; &gt; | &lt; EVERY: &quot;EVERY&quot; &gt; | &lt; EXCEPT: &quot;EXCEPT&quot; &gt; | &lt; EXCEPTION: &quot;EXCEPTION&quot; &gt; | &lt; EXCLUDE: &quot;EXCLUDE&quot; &gt; | &lt; EXCLUDING: &quot;EXCLUDING&quot; &gt; | &lt; EXEC: &quot;EXEC&quot; &gt; | &lt; EXECUTE: &quot;EXECUTE&quot; &gt; | &lt; EXISTS: &quot;EXISTS&quot; &gt; | &lt; EXP: &quot;EXP&quot; &gt; | &lt; EXPLAIN: &quot;EXPLAIN&quot; &gt; | &lt; EXTEND: &quot;EXTEND&quot; &gt; | &lt; EXTERNAL: &quot;EXTERNAL&quot; &gt; | &lt; EXTRACT: &quot;EXTRACT&quot; &gt; | &lt; FALSE: &quot;FALSE&quot; &gt; | &lt; FETCH: &quot;FETCH&quot; &gt; | &lt; FILTER: &quot;FILTER&quot; &gt; | &lt; FINAL: &quot;FINAL&quot; &gt; | &lt; FIRST: &quot;FIRST&quot; &gt; | &lt; FIRST_VALUE: &quot;FIRST_VALUE&quot;&gt; | &lt; FLOAT: &quot;FLOAT&quot; &gt; | &lt; FLOOR: &quot;FLOOR&quot; &gt; | &lt; FOLLOWING: &quot;FOLLOWING&quot; &gt; | &lt; FOR: &quot;FOR&quot; &gt; | &lt; FORMAT: &quot;FORMAT&quot; &gt; | &lt; FOREIGN: &quot;FOREIGN&quot; &gt; | &lt; FORTRAN: &quot;FORTRAN&quot; &gt; | &lt; FOUND: &quot;FOUND&quot; &gt; | &lt; FRAC_SECOND: &quot;FRAC_SECOND&quot; &gt; | &lt; FRAME_ROW: &quot;FRAME_ROW&quot; &gt; | &lt; FREE: &quot;FREE&quot; &gt; | &lt; FROM: &quot;FROM&quot; &gt; { beforeTableName(); } | &lt; FULL: &quot;FULL&quot; &gt; | &lt; FUNCTION: &quot;FUNCTION&quot; &gt; | &lt; FUSION: &quot;FUSION&quot; &gt; | &lt; G: &quot;G&quot; &gt; | &lt; GENERAL: &quot;GENERAL&quot; &gt; | &lt; GENERATED: &quot;GENERATED&quot; &gt; | &lt; GEOMETRY: &quot;GEOMETRY&quot; &gt; | &lt; GET: &quot;GET&quot; &gt; | &lt; GLOBAL: &quot;GLOBAL&quot; &gt; | &lt; GO: &quot;GO&quot; &gt; | &lt; GOTO: &quot;GOTO&quot; &gt; | &lt; GRANT: &quot;GRANT&quot; &gt; | &lt; GRANTED: &quot;GRANTED&quot; &gt; | &lt; GROUP: &quot;GROUP&quot; &gt; | &lt; GROUPING: &quot;GROUPING&quot; &gt; | &lt; GROUPS: &quot;GROUPS&quot; &gt; | &lt; HAVING: &quot;HAVING&quot; &gt; | &lt; HIERARCHY: &quot;HIERARCHY&quot; &gt; | &lt; HOLD: &quot;HOLD&quot; &gt; | &lt; HOP: &quot;HOP&quot; &gt; | &lt; HOUR: &quot;HOUR&quot; &gt; | &lt; HOURS: &quot;HOURS&quot; &gt; | &lt; IDENTITY: &quot;IDENTITY&quot; &gt; | &lt; IGNORE: &quot;IGNORE&quot; &gt; | &lt; IMMEDIATE: &quot;IMMEDIATE&quot; &gt; | &lt; IMMEDIATELY: &quot;IMMEDIATELY&quot; &gt; | &lt; IMPLEMENTATION: &quot;IMPLEMENTATION&quot; &gt; | &lt; IMPORT: &quot;IMPORT&quot; &gt; | &lt; IN: &quot;IN&quot; &gt; | &lt; INCLUDING: &quot;INCLUDING&quot; &gt; | &lt; INCREMENT: &quot;INCREMENT&quot; &gt; | &lt; INDICATOR: &quot;INDICATOR&quot; &gt; | &lt; INITIAL: &quot;INITIAL&quot; &gt; | &lt; INITIALLY: &quot;INITIALLY&quot; &gt; | &lt; INNER: &quot;INNER&quot; &gt; | &lt; INOUT: &quot;INOUT&quot; &gt; | &lt; INPUT: &quot;INPUT&quot; &gt; | &lt; INSENSITIVE: &quot;INSENSITIVE&quot; &gt; | &lt; INSERT: &quot;INSERT&quot; &gt; { beforeTableName(); } | &lt; INSTANCE: &quot;INSTANCE&quot; &gt; | &lt; INSTANTIABLE: &quot;INSTANTIABLE&quot; &gt; | &lt; INT: &quot;INT&quot; &gt; | &lt; INTEGER: &quot;INTEGER&quot; &gt; | &lt; INTERSECT: &quot;INTERSECT&quot; &gt; | &lt; INTERSECTION: &quot;INTERSECTION&quot; &gt; | &lt; INTERVAL: &quot;INTERVAL&quot; &gt; | &lt; INTO: &quot;INTO&quot; &gt; | &lt; INVOKER: &quot;INVOKER&quot; &gt; | &lt; IS: &quot;IS&quot; &gt; | &lt; ISODOW: &quot;ISODOW&quot; &gt; | &lt; ISOYEAR: &quot;ISOYEAR&quot; &gt; | &lt; ISOLATION: &quot;ISOLATION&quot; &gt; | &lt; JAVA: &quot;JAVA&quot; &gt; | &lt; JOIN: &quot;JOIN&quot; &gt; { beforeTableName(); } | &lt; JSON: &quot;JSON&quot; &gt; | &lt; JSON_ARRAY: &quot;JSON_ARRAY&quot;&gt; | &lt; JSON_ARRAYAGG: &quot;JSON_ARRAYAGG&quot;&gt; | &lt; JSON_EXISTS: &quot;JSON_EXISTS&quot; &gt; | &lt; JSON_OBJECT: &quot;JSON_OBJECT&quot;&gt; | &lt; JSON_OBJECTAGG: &quot;JSON_OBJECTAGG&quot;&gt; | &lt; JSON_QUERY: &quot;JSON_QUERY&quot; &gt; | &lt; JSON_VALUE: &quot;JSON_VALUE&quot; &gt; | &lt; K: &quot;K&quot; &gt; | &lt; KEY: &quot;KEY&quot; &gt; | &lt; KEY_MEMBER: &quot;KEY_MEMBER&quot; &gt; | &lt; KEY_TYPE: &quot;KEY_TYPE&quot; &gt; | &lt; LABEL: &quot;LABEL&quot; &gt; | &lt; LAG: &quot;LAG&quot; &gt; | &lt; LANGUAGE: &quot;LANGUAGE&quot; &gt; | &lt; LARGE: &quot;LARGE&quot; &gt; | &lt; LAST: &quot;LAST&quot; &gt; | &lt; LAST_VALUE: &quot;LAST_VALUE&quot; &gt; | &lt; LATERAL: &quot;LATERAL&quot; &gt; | &lt; LEAD: &quot;LEAD&quot; &gt; | &lt; LEADING: &quot;LEADING&quot; &gt; | &lt; LEFT: &quot;LEFT&quot; &gt; | &lt; LENGTH: &quot;LENGTH&quot; &gt; | &lt; LEVEL: &quot;LEVEL&quot; &gt; | &lt; LIBRARY: &quot;LIBRARY&quot; &gt; | &lt; LIKE: &quot;LIKE&quot; &gt; | &lt; LIKE_REGEX: &quot;LIKE_REGEX&quot; &gt; | &lt; LIMIT: &quot;LIMIT&quot; &gt; | &lt; LN: &quot;LN&quot; &gt; | &lt; LOCAL: &quot;LOCAL&quot; &gt; | &lt; LOCALTIME: &quot;LOCALTIME&quot; &gt; | &lt; LOCALTIMESTAMP: &quot;LOCALTIMESTAMP&quot; &gt; | &lt; LOCATOR: &quot;LOCATOR&quot; &gt; | &lt; LOWER: &quot;LOWER&quot; &gt; | &lt; M: &quot;M&quot; &gt; | &lt; MAP: &quot;MAP&quot; &gt; | &lt; MATCH: &quot;MATCH&quot; &gt; | &lt; MATCHED: &quot;MATCHED&quot; &gt; | &lt; MATCHES: &quot;MATCHES&quot; &gt; | &lt; MATCH_NUMBER: &quot;MATCH_NUMBER&quot;&gt; | &lt; MATCH_RECOGNIZE: &quot;MATCH_RECOGNIZE&quot;&gt; | &lt; MAX: &quot;MAX&quot; &gt; | &lt; MAXVALUE: &quot;MAXVALUE&quot; &gt; | &lt; MEASURES: &quot;MEASURES&quot; &gt; | &lt; MEMBER: &quot;MEMBER&quot; &gt; | &lt; MERGE: &quot;MERGE&quot; &gt; { beforeTableName(); } | &lt; MESSAGE_LENGTH: &quot;MESSAGE_LENGTH&quot; &gt; | &lt; MESSAGE_OCTET_LENGTH: &quot;MESSAGE_OCTET_LENGTH&quot; &gt; | &lt; MESSAGE_TEXT: &quot;MESSAGE_TEXT&quot; &gt; | &lt; METHOD: &quot;METHOD&quot; &gt; | &lt; MICROSECOND: &quot;MICROSECOND&quot; &gt; | &lt; MILLISECOND: &quot;MILLISECOND&quot; &gt; | &lt; MILLENNIUM: &quot;MILLENNIUM&quot; &gt; | &lt; MIN: &quot;MIN&quot; &gt; | &lt; MINUTE: &quot;MINUTE&quot; &gt; | &lt; MINUTES: &quot;MINUTES&quot; &gt; | &lt; MINVALUE: &quot;MINVALUE&quot; &gt; | &lt; MOD: &quot;MOD&quot; &gt; | &lt; MODIFIES: &quot;MODIFIES&quot; &gt; | &lt; MONTH: &quot;MONTH&quot; &gt; | &lt; MONTHS: &quot;MONTHS&quot; &gt; | &lt; MORE_: &quot;MORE&quot; &gt; | &lt; MULTISET: &quot;MULTISET&quot; &gt; | &lt; MUMPS: &quot;MUMPS&quot; &gt; | &lt; NAME: &quot;NAME&quot; &gt; | &lt; NAMES: &quot;NAMES&quot; &gt; | &lt; NANOSECOND: &quot;NANOSECOND&quot; &gt; | &lt; NATIONAL: &quot;NATIONAL&quot; &gt; | &lt; NATURAL: &quot;NATURAL&quot; &gt; | &lt; NCHAR: &quot;NCHAR&quot; &gt; | &lt; NCLOB: &quot;NCLOB&quot; &gt; | &lt; NESTING: &quot;NESTING&quot; &gt; | &lt; NEW: &quot;NEW&quot; &gt; | &lt; NEXT: &quot;NEXT&quot; &gt; | &lt; NO: &quot;NO&quot; &gt; | &lt; NONE: &quot;NONE&quot; &gt; | &lt; NORMALIZE: &quot;NORMALIZE&quot; &gt; | &lt; NORMALIZED: &quot;NORMALIZED&quot; &gt; | &lt; NOT: &quot;NOT&quot; &gt; | &lt; NTH_VALUE: &quot;NTH_VALUE&quot; &gt; | &lt; NTILE: &quot;NTILE&quot; &gt; | &lt; NULL: &quot;NULL&quot; &gt; | &lt; NULLABLE: &quot;NULLABLE&quot; &gt; | &lt; NULLIF: &quot;NULLIF&quot; &gt; | &lt; NULLS: &quot;NULLS&quot; &gt; | &lt; NUMBER: &quot;NUMBER&quot; &gt; | &lt; NUMERIC: &quot;NUMERIC&quot; &gt; | &lt; OBJECT: &quot;OBJECT&quot; &gt; | &lt; OCCURRENCES_REGEX: &quot;OCCURRENCES_REGEX&quot; &gt; | &lt; OCTET_LENGTH: &quot;OCTET_LENGTH&quot; &gt; | &lt; OCTETS: &quot;OCTETS&quot; &gt; | &lt; OF: &quot;OF&quot; &gt; | &lt; OFFSET: &quot;OFFSET&quot; &gt; | &lt; OLD: &quot;OLD&quot; &gt; | &lt; OMIT: &quot;OMIT&quot; &gt; | &lt; ON: &quot;ON&quot; &gt; | &lt; ONE: &quot;ONE&quot; &gt; | &lt; ONLY: &quot;ONLY&quot; &gt; | &lt; OPEN: &quot;OPEN&quot; &gt; | &lt; OPTION: &quot;OPTION&quot; &gt; | &lt; OPTIONS: &quot;OPTIONS&quot; &gt; | &lt; OR: &quot;OR&quot; &gt; | &lt; ORDER: &quot;ORDER&quot; &gt; | &lt; ORDERING: &quot;ORDERING&quot; &gt; | &lt; ORDINALITY: &quot;ORDINALITY&quot; &gt; | &lt; OTHERS: &quot;OTHERS&quot; &gt; | &lt; OUT: &quot;OUT&quot; &gt; | &lt; OUTER: &quot;OUTER&quot; &gt; | &lt; OUTPUT: &quot;OUTPUT&quot; &gt; | &lt; OVER: &quot;OVER&quot; &gt; | &lt; OVERLAPS: &quot;OVERLAPS&quot; &gt; | &lt; OVERLAY: &quot;OVERLAY&quot; &gt; | &lt; OVERRIDING: &quot;OVERRIDING&quot; &gt; | &lt; PAD: &quot;PAD&quot; &gt; | &lt; PARAMETER: &quot;PARAMETER&quot; &gt; | &lt; PARAMETER_MODE: &quot;PARAMETER_MODE&quot; &gt; | &lt; PARAMETER_NAME: &quot;PARAMETER_NAME&quot; &gt; | &lt; PARAMETER_ORDINAL_POSITION: &quot;PARAMETER_ORDINAL_POSITION&quot; &gt; | &lt; PARAMETER_SPECIFIC_CATALOG: &quot;PARAMETER_SPECIFIC_CATALOG&quot; &gt; | &lt; PARAMETER_SPECIFIC_NAME: &quot;PARAMETER_SPECIFIC_NAME&quot; &gt; | &lt; PARAMETER_SPECIFIC_SCHEMA: &quot;PARAMETER_SPECIFIC_SCHEMA&quot; &gt; | &lt; PARTIAL: &quot;PARTIAL&quot; &gt; | &lt; PARTITION: &quot;PARTITION&quot; &gt; | &lt; PASCAL: &quot;PASCAL&quot; &gt; | &lt; PASSING: &quot;PASSING&quot; &gt; | &lt; PASSTHROUGH: &quot;PASSTHROUGH&quot; &gt; | &lt; PAST: &quot;PAST&quot; &gt; | &lt; PATH: &quot;PATH&quot; &gt; | &lt; PATTERN: &quot;PATTERN&quot; &gt; | &lt; PER: &quot;PER&quot; &gt; | &lt; PERCENT: &quot;PERCENT&quot; &gt; | &lt; PERCENTILE_CONT: &quot;PERCENTILE_CONT&quot; &gt; | &lt; PERCENTILE_DISC: &quot;PERCENTILE_DISC&quot; &gt; | &lt; PERCENT_RANK: &quot;PERCENT_RANK&quot; &gt; | &lt; PERIOD: &quot;PERIOD&quot; &gt; | &lt; PERMUTE: &quot;PERMUTE&quot; &gt; | &lt; PIVOT: &quot;PIVOT&quot; &gt; | &lt; PLACING: &quot;PLACING&quot; &gt; | &lt; PLAN: &quot;PLAN&quot; &gt; | &lt; PLI: &quot;PLI&quot; &gt; | &lt; PORTION: &quot;PORTION&quot; &gt; | &lt; POSITION: &quot;POSITION&quot; &gt; | &lt; POSITION_REGEX: &quot;POSITION_REGEX&quot; &gt; | &lt; POWER: &quot;POWER&quot; &gt; | &lt; PRECEDES: &quot;PRECEDES&quot; &gt; | &lt; PRECEDING: &quot;PRECEDING&quot; &gt; | &lt; PRECISION: &quot;PRECISION&quot; &gt; | &lt; PREPARE: &quot;PREPARE&quot; &gt; | &lt; PRESERVE: &quot;PRESERVE&quot; &gt; | &lt; PREV: &quot;PREV&quot; &gt; | &lt; PRIMARY: &quot;PRIMARY&quot; &gt; | &lt; PRIOR: &quot;PRIOR&quot; &gt; | &lt; PRIVILEGES: &quot;PRIVILEGES&quot; &gt; | &lt; PROCEDURE: &quot;PROCEDURE&quot; &gt; | &lt; PUBLIC: &quot;PUBLIC&quot; &gt; | &lt; QUARTER: &quot;QUARTER&quot; &gt; | &lt; RANGE: &quot;RANGE&quot; &gt; | &lt; RANK: &quot;RANK&quot; &gt; | &lt; READ: &quot;READ&quot; &gt; | &lt; READS: &quot;READS&quot; &gt; | &lt; REAL: &quot;REAL&quot; &gt; | &lt; RECURSIVE: &quot;RECURSIVE&quot; &gt; | &lt; REF: &quot;REF&quot; &gt; | &lt; REFERENCES: &quot;REFERENCES&quot; &gt; | &lt; REFERENCING: &quot;REFERENCING&quot; &gt; | &lt; REGR_AVGX: &quot;REGR_AVGX&quot; &gt; | &lt; REGR_AVGY: &quot;REGR_AVGY&quot; &gt; | &lt; REGR_COUNT: &quot;REGR_COUNT&quot; &gt; | &lt; REGR_INTERCEPT: &quot;REGR_INTERCEPT&quot; &gt; | &lt; REGR_R2: &quot;REGR_R2&quot; &gt; | &lt; REGR_SLOPE: &quot;REGR_SLOPE&quot; &gt; | &lt; REGR_SXX: &quot;REGR_SXX&quot; &gt; | &lt; REGR_SXY: &quot;REGR_SXY&quot; &gt; | &lt; REGR_SYY: &quot;REGR_SYY&quot; &gt; | &lt; RELATIVE: &quot;RELATIVE&quot; &gt; | &lt; RELEASE: &quot;RELEASE&quot; &gt; | &lt; REPEATABLE: &quot;REPEATABLE&quot; &gt; | &lt; REPLACE: &quot;REPLACE&quot; &gt; | &lt; RESET: &quot;RESET&quot; &gt; | &lt; RESPECT: &quot;RESPECT&quot; &gt; | &lt; RESTART: &quot;RESTART&quot; &gt; | &lt; RESTRICT: &quot;RESTRICT&quot; &gt; | &lt; RESULT: &quot;RESULT&quot; &gt; | &lt; RETURN: &quot;RETURN&quot; &gt; | &lt; RETURNED_CARDINALITY: &quot;RETURNED_CARDINALITY&quot; &gt; | &lt; RETURNED_LENGTH: &quot;RETURNED_LENGTH&quot; &gt; | &lt; RETURNED_OCTET_LENGTH: &quot;RETURNED_OCTET_LENGTH&quot; &gt; | &lt; RETURNED_SQLSTATE: &quot;RETURNED_SQLSTATE&quot; &gt; | &lt; RETURNING: &quot;RETURNING&quot; &gt; | &lt; RETURNS: &quot;RETURNS&quot; &gt; | &lt; REVOKE: &quot;REVOKE&quot; &gt; | &lt; RIGHT: &quot;RIGHT&quot; &gt; | &lt; ROLE: &quot;ROLE&quot; &gt; | &lt; ROLLBACK: &quot;ROLLBACK&quot; &gt; | &lt; ROLLUP: &quot;ROLLUP&quot; &gt; | &lt; ROUTINE: &quot;ROUTINE&quot; &gt; | &lt; ROUTINE_CATALOG: &quot;ROUTINE_CATALOG&quot; &gt; | &lt; ROUTINE_NAME: &quot;ROUTINE_NAME&quot; &gt; | &lt; ROUTINE_SCHEMA: &quot;ROUTINE_SCHEMA&quot; &gt; | &lt; ROW: &quot;ROW&quot; &gt; | &lt; ROW_COUNT: &quot;ROW_COUNT&quot; &gt; | &lt; ROW_NUMBER: &quot;ROW_NUMBER&quot; &gt; | &lt; ROWS: &quot;ROWS&quot; &gt; | &lt; RUNNING: &quot;RUNNING&quot; &gt; | &lt; SAVEPOINT: &quot;SAVEPOINT&quot; &gt; | &lt; SCALAR: &quot;SCALAR&quot; &gt; | &lt; SCALE: &quot;SCALE&quot; &gt; | &lt; SCHEMA: &quot;SCHEMA&quot; &gt; | &lt; SCHEMA_NAME: &quot;SCHEMA_NAME&quot; &gt; | &lt; SCOPE: &quot;SCOPE&quot; &gt; | &lt; SCOPE_CATALOGS: &quot;SCOPE_CATALOGS&quot; &gt; | &lt; SCOPE_NAME: &quot;SCOPE_NAME&quot; &gt; | &lt; SCOPE_SCHEMA: &quot;SCOPE_SCHEMA&quot; &gt; | &lt; SCROLL: &quot;SCROLL&quot; &gt; | &lt; SEARCH: &quot;SEARCH&quot; &gt; | &lt; SECOND: &quot;SECOND&quot; &gt; | &lt; SECONDS: &quot;SECONDS&quot; &gt; | &lt; SECTION: &quot;SECTION&quot; &gt; | &lt; SECURITY: &quot;SECURITY&quot; &gt; | &lt; SEEK: &quot;SEEK&quot; &gt; | &lt; SELECT: &quot;SELECT&quot; &gt; { afterTableName(); } | &lt; SELF: &quot;SELF&quot; &gt; | &lt; SENSITIVE: &quot;SENSITIVE&quot; &gt; | &lt; SEQUENCE: &quot;SEQUENCE&quot; &gt; | &lt; SERIALIZABLE: &quot;SERIALIZABLE&quot; &gt; | &lt; SERVER: &quot;SERVER&quot; &gt; | &lt; SERVER_NAME: &quot;SERVER_NAME&quot; &gt; | &lt; SESSION: &quot;SESSION&quot; &gt; | &lt; SESSION_USER: &quot;SESSION_USER&quot; &gt; | &lt; SET: &quot;SET&quot; &gt; { afterTableName(); } | &lt; SETS: &quot;SETS&quot; &gt; | &lt; SET_MINUS: &quot;MINUS&quot;&gt; | &lt; SHOW: &quot;SHOW&quot; &gt; | &lt; SIMILAR: &quot;SIMILAR&quot; &gt; | &lt; SIMPLE: &quot;SIMPLE&quot; &gt; | &lt; SIZE: &quot;SIZE&quot; &gt; | &lt; SKIP_: &quot;SKIP&quot; &gt; | &lt; SMALLINT: &quot;SMALLINT&quot; &gt; | &lt; SOME: &quot;SOME&quot; &gt; | &lt; SOURCE: &quot;SOURCE&quot; &gt; | &lt; SPACE: &quot;SPACE&quot; &gt; | &lt; SPECIFIC: &quot;SPECIFIC&quot; &gt; | &lt; SPECIFIC_NAME: &quot;SPECIFIC_NAME&quot; &gt; | &lt; SPECIFICTYPE: &quot;SPECIFICTYPE&quot; &gt; | &lt; SQL: &quot;SQL&quot; &gt; | &lt; SQLEXCEPTION: &quot;SQLEXCEPTION&quot; &gt; | &lt; SQLSTATE: &quot;SQLSTATE&quot; &gt; | &lt; SQLWARNING: &quot;SQLWARNING&quot; &gt; | &lt; SQL_BIGINT: &quot;SQL_BIGINT&quot; &gt; | &lt; SQL_BINARY: &quot;SQL_BINARY&quot; &gt; | &lt; SQL_BIT: &quot;SQL_BIT&quot; &gt; | &lt; SQL_BLOB: &quot;SQL_BLOB&quot; &gt; | &lt; SQL_BOOLEAN: &quot;SQL_BOOLEAN&quot; &gt; | &lt; SQL_CHAR: &quot;SQL_CHAR&quot; &gt; | &lt; SQL_CLOB: &quot;SQL_CLOB&quot; &gt; | &lt; SQL_DATE: &quot;SQL_DATE&quot; &gt; | &lt; SQL_DECIMAL: &quot;SQL_DECIMAL&quot; &gt; | &lt; SQL_DOUBLE: &quot;SQL_DOUBLE&quot; &gt; | &lt; SQL_FLOAT: &quot;SQL_FLOAT&quot; &gt; | &lt; SQL_INTEGER: &quot;SQL_INTEGER&quot; &gt; | &lt; SQL_INTERVAL_DAY: &quot;SQL_INTERVAL_DAY&quot; &gt; | &lt; SQL_INTERVAL_DAY_TO_HOUR: &quot;SQL_INTERVAL_DAY_TO_HOUR&quot; &gt; | &lt; SQL_INTERVAL_DAY_TO_MINUTE: &quot;SQL_INTERVAL_DAY_TO_MINUTE&quot; &gt; | &lt; SQL_INTERVAL_DAY_TO_SECOND: &quot;SQL_INTERVAL_DAY_TO_SECOND&quot; &gt; | &lt; SQL_INTERVAL_HOUR: &quot;SQL_INTERVAL_HOUR&quot; &gt; | &lt; SQL_INTERVAL_HOUR_TO_MINUTE: &quot;SQL_INTERVAL_HOUR_TO_MINUTE&quot; &gt; | &lt; SQL_INTERVAL_HOUR_TO_SECOND: &quot;SQL_INTERVAL_HOUR_TO_SECOND&quot; &gt; | &lt; SQL_INTERVAL_MINUTE: &quot;SQL_INTERVAL_MINUTE&quot; &gt; | &lt; SQL_INTERVAL_MINUTE_TO_SECOND: &quot;SQL_INTERVAL_MINUTE_TO_SECOND&quot; &gt; | &lt; SQL_INTERVAL_MONTH: &quot;SQL_INTERVAL_MONTH&quot; &gt; | &lt; SQL_INTERVAL_SECOND: &quot;SQL_INTERVAL_SECOND&quot; &gt; | &lt; SQL_INTERVAL_YEAR: &quot;SQL_INTERVAL_YEAR&quot; &gt; | &lt; SQL_INTERVAL_YEAR_TO_MONTH: &quot;SQL_INTERVAL_YEAR_TO_MONTH&quot; &gt; | &lt; SQL_LONGVARBINARY: &quot;SQL_LONGVARBINARY&quot; &gt; | &lt; SQL_LONGVARCHAR: &quot;SQL_LONGVARCHAR&quot; &gt; | &lt; SQL_LONGVARNCHAR: &quot;SQL_LONGVARNCHAR&quot; &gt; | &lt; SQL_NCHAR: &quot;SQL_NCHAR&quot; &gt; | &lt; SQL_NCLOB: &quot;SQL_NCLOB&quot; &gt; | &lt; SQL_NUMERIC: &quot;SQL_NUMERIC&quot; &gt; | &lt; SQL_NVARCHAR: &quot;SQL_NVARCHAR&quot; &gt; | &lt; SQL_REAL: &quot;SQL_REAL&quot; &gt; | &lt; SQL_SMALLINT: &quot;SQL_SMALLINT&quot; &gt; | &lt; SQL_TIME: &quot;SQL_TIME&quot; &gt; | &lt; SQL_TIMESTAMP: &quot;SQL_TIMESTAMP&quot; &gt; | &lt; SQL_TINYINT: &quot;SQL_TINYINT&quot; &gt; | &lt; SQL_TSI_DAY: &quot;SQL_TSI_DAY&quot; &gt; | &lt; SQL_TSI_FRAC_SECOND: &quot;SQL_TSI_FRAC_SECOND&quot; &gt; | &lt; SQL_TSI_HOUR: &quot;SQL_TSI_HOUR&quot; &gt; | &lt; SQL_TSI_MICROSECOND: &quot;SQL_TSI_MICROSECOND&quot; &gt; | &lt; SQL_TSI_MINUTE: &quot;SQL_TSI_MINUTE&quot; &gt; | &lt; SQL_TSI_MONTH: &quot;SQL_TSI_MONTH&quot; &gt; | &lt; SQL_TSI_QUARTER: &quot;SQL_TSI_QUARTER&quot; &gt; | &lt; SQL_TSI_SECOND: &quot;SQL_TSI_SECOND&quot; &gt; | &lt; SQL_TSI_WEEK: &quot;SQL_TSI_WEEK&quot; &gt; | &lt; SQL_TSI_YEAR: &quot;SQL_TSI_YEAR&quot; &gt; | &lt; SQL_VARBINARY: &quot;SQL_VARBINARY&quot; &gt; | &lt; SQL_VARCHAR: &quot;SQL_VARCHAR&quot; &gt; | &lt; SQRT: &quot;SQRT&quot; &gt; | &lt; START: &quot;START&quot; &gt; | &lt; STATE: &quot;STATE&quot; &gt; | &lt; STATEMENT: &quot;STATEMENT&quot; &gt; | &lt; STATIC: &quot;STATIC&quot; &gt; | &lt; STDDEV_POP: &quot;STDDEV_POP&quot; &gt; | &lt; STDDEV_SAMP: &quot;STDDEV_SAMP&quot; &gt; | &lt; STREAM: &quot;STREAM&quot; &gt; | &lt; STRUCTURE: &quot;STRUCTURE&quot; &gt; | &lt; STYLE: &quot;STYLE&quot; &gt; | &lt; SUBCLASS_ORIGIN: &quot;SUBCLASS_ORIGIN&quot; &gt; | &lt; SUBMULTISET: &quot;SUBMULTISET&quot; &gt; | &lt; SUBSET: &quot;SUBSET&quot; &gt; | &lt; SUBSTITUTE: &quot;SUBSTITUTE&quot; &gt; | &lt; SUBSTRING: &quot;SUBSTRING&quot; &gt; | &lt; SUBSTRING_REGEX: &quot;SUBSTRING_REGEX&quot; &gt; | &lt; SUCCEEDS: &quot;SUCCEEDS&quot; &gt; | &lt; SUM: &quot;SUM&quot; &gt; | &lt; SYMMETRIC: &quot;SYMMETRIC&quot; &gt; | &lt; SYSTEM: &quot;SYSTEM&quot; &gt; | &lt; SYSTEM_TIME: &quot;SYSTEM_TIME&quot; &gt; | &lt; SYSTEM_USER: &quot;SYSTEM_USER&quot; &gt; | &lt; TABLE: &quot;TABLE&quot; &gt; { beforeTableName(); } | &lt; TABLE_NAME: &quot;TABLE_NAME&quot; &gt; | &lt; TABLESAMPLE: &quot;TABLESAMPLE&quot; &gt; | &lt; TEMPORARY: &quot;TEMPORARY&quot; &gt; | &lt; THEN: &quot;THEN&quot; &gt; | &lt; TIES: &quot;TIES&quot; &gt; | &lt; TIME: &quot;TIME&quot; &gt; | &lt; TIMESTAMP: &quot;TIMESTAMP&quot; &gt; | &lt; TIMESTAMPADD: &quot;TIMESTAMPADD&quot; &gt; | &lt; TIMESTAMPDIFF: &quot;TIMESTAMPDIFF&quot; &gt; | &lt; TIMEZONE_HOUR: &quot;TIMEZONE_HOUR&quot; &gt; | &lt; TIMEZONE_MINUTE: &quot;TIMEZONE_MINUTE&quot; &gt; | &lt; TINYINT: &quot;TINYINT&quot; &gt; | &lt; TO: &quot;TO&quot; &gt; | &lt; TOP_LEVEL_COUNT: &quot;TOP_LEVEL_COUNT&quot; &gt; | &lt; TRAILING: &quot;TRAILING&quot; &gt; | &lt; TRANSACTION: &quot;TRANSACTION&quot; &gt; | &lt; TRANSACTIONS_ACTIVE: &quot;TRANSACTIONS_ACTIVE&quot; &gt; | &lt; TRANSACTIONS_COMMITTED: &quot;TRANSACTIONS_COMMITTED&quot; &gt; | &lt; TRANSACTIONS_ROLLED_BACK: &quot;TRANSACTIONS_ROLLED_BACK&quot; &gt; | &lt; TRANSFORM: &quot;TRANSFORM&quot; &gt; | &lt; TRANSFORMS: &quot;TRANSFORMS&quot; &gt; | &lt; TRANSLATE: &quot;TRANSLATE&quot; &gt; | &lt; TRANSLATE_REGEX: &quot;TRANSLATE_REGEX&quot; &gt; | &lt; TRANSLATION: &quot;TRANSLATION&quot; &gt; | &lt; TREAT: &quot;TREAT&quot; &gt; | &lt; TRIGGER: &quot;TRIGGER&quot; &gt; | &lt; TRIGGER_CATALOG: &quot;TRIGGER_CATALOG&quot; &gt; | &lt; TRIGGER_NAME: &quot;TRIGGER_NAME&quot; &gt; | &lt; TRIGGER_SCHEMA: &quot;TRIGGER_SCHEMA&quot; &gt; | &lt; TRIM: &quot;TRIM&quot; &gt; | &lt; TRIM_ARRAY: &quot;TRIM_ARRAY&quot; &gt; | &lt; TRUE: &quot;TRUE&quot; &gt; | &lt; TRUNCATE: &quot;TRUNCATE&quot; &gt; | &lt; TUMBLE: &quot;TUMBLE&quot; &gt; | &lt; TYPE_Q: &quot;TYPE_Q&quot; &gt; | &lt; UESCAPE: &quot;UESCAPE&quot; &gt; | &lt; UNBOUNDED: &quot;UNBOUNDED&quot; &gt; | &lt; UNCOMMITTED: &quot;UNCOMMITTED&quot; &gt; | &lt; UNCONDITIONAL: &quot;UNCONDITIONAL&quot; &gt; | &lt; UNDER: &quot;UNDER&quot; &gt; | &lt; UNION: &quot;UNION&quot; &gt; | &lt; UNIQUE: &quot;UNIQUE&quot; &gt; | &lt; UNKNOWN: &quot;UNKNOWN&quot; &gt; | &lt; UNNAMED: &quot;UNNAMED&quot; &gt; | &lt; UNNEST: &quot;UNNEST&quot; &gt; | &lt; UPDATE: &quot;UPDATE&quot; &gt; { beforeTableName(); } | &lt; UPPER: &quot;UPPER&quot; &gt; | &lt; UPSERT: &quot;UPSERT&quot; &gt; | &lt; USAGE: &quot;USAGE&quot; &gt; | &lt; USER: &quot;USER&quot; &gt; | &lt; USER_DEFINED_TYPE_CATALOG: &quot;USER_DEFINED_TYPE_CATALOG&quot; &gt; | &lt; USER_DEFINED_TYPE_CODE: &quot;USER_DEFINED_TYPE_CODE&quot; &gt; | &lt; USER_DEFINED_TYPE_NAME: &quot;USER_DEFINED_TYPE_NAME&quot; &gt; | &lt; USER_DEFINED_TYPE_SCHEMA: &quot;USER_DEFINED_TYPE_SCHEMA&quot; &gt; | &lt; USING: &quot;USING&quot; &gt; | &lt; UTF8: &quot;UTF8&quot; &gt; | &lt; UTF16: &quot;UTF16&quot; &gt; | &lt; UTF32: &quot;UTF32&quot; &gt; | &lt; VALUE: &quot;VALUE&quot; &gt; | &lt; VALUES: &quot;VALUES&quot; &gt; { afterTableName(); } | &lt; VALUE_OF: &quot;VALUE_OF&quot; &gt; | &lt; VAR_POP: &quot;VAR_POP&quot; &gt; | &lt; VAR_SAMP: &quot;VAR_SAMP&quot; &gt; | &lt; VARBINARY: &quot;VARBINARY&quot; &gt; | &lt; VARCHAR: &quot;VARCHAR&quot; &gt; | &lt; VARYING: &quot;VARYING&quot; &gt; | &lt; VERSION: &quot;VERSION&quot; &gt; | &lt; VERSIONING: &quot;VERSIONING&quot; &gt; | &lt; VIEW: &quot;VIEW&quot; &gt; | &lt; WEEK: &quot;WEEK&quot; &gt; | &lt; WHEN: &quot;WHEN&quot; &gt; | &lt; WHENEVER: &quot;WHENEVER&quot; &gt; | &lt; WHERE: &quot;WHERE&quot; &gt; | &lt; WIDTH_BUCKET: &quot;WIDTH_BUCKET&quot; &gt; | &lt; WINDOW: &quot;WINDOW&quot; &gt; | &lt; WITH: &quot;WITH&quot; &gt; | &lt; WITHIN: &quot;WITHIN&quot; &gt; | &lt; WITHOUT: &quot;WITHOUT&quot; &gt; | &lt; WORK: &quot;WORK&quot; &gt; | &lt; WRAPPER: &quot;WRAPPER&quot; &gt; | &lt; WRITE: &quot;WRITE&quot; &gt; | &lt; XML: &quot;XML&quot; &gt; | &lt; YEAR: &quot;YEAR&quot; &gt; | &lt; YEARS: &quot;YEARS&quot; &gt; | &lt; ZONE: &quot;ZONE&quot; &gt; &lt;-- additional parser keywords are included here --&gt; &lt;list (parser.keywords!default.parser.keywords) as keyword&gt; | &lt; {keyword}: &quot;{keyword}&quot; &gt; &lt;list&gt; } Parses a non-reserved keyword for use as an identifier. &lt;p&gt;The method is broken up into several sub-methods; without this decomposition, parsers such as Babel with more than ~1,000 non-reserved keywords would generate such deeply nested 'if' statements that javac would fail with a {@link StackOverflowError}. &lt;p&gt;The list is generated from the FMPP config data. To add or remove keywords, modify config.fmpp. For parsers except Babel, make sure that keywords are not reserved by the SQL standard. @see GlossarySQL2003 SQL:2003 Part 2 Section 5.2 String NonReservedKeyWord() : { } { ( NonReservedKeyWord0of3() | NonReservedKeyWord1of3() | NonReservedKeyWord2of3() ) { return unquotedIdentifier(); } } @see NonReservedKeyWord void NonReservedKeyWord0of3() : { } { ( &lt;list (parser.nonReservedKeywords!default.parser.nonReservedKeywords) + (parser.nonReservedKeywordsToAdd!default.parser.nonReservedKeywordsToAdd) as keyword&gt; &lt;if keyword?index == 0&gt; &lt;{keyword}&gt; &lt;elseif keyword?index % 3 == 0&gt; | &lt;{keyword}&gt; &lt;if&gt; &lt;list&gt; ) } @see NonReservedKeyWord void NonReservedKeyWord1of3() : { } { ( &lt;list (parser.nonReservedKeywords!default.parser.nonReservedKeywords) + (parser.nonReservedKeywordsToAdd!default.parser.nonReservedKeywordsToAdd) as keyword&gt; &lt;if keyword?index == 1&gt; &lt;{keyword}&gt; &lt;elseif keyword?index % 3 == 1&gt; | &lt;{keyword}&gt; &lt;if&gt; &lt;list&gt; ) } @see NonReservedKeyWord void NonReservedKeyWord2of3() : { } { ( &lt;list (parser.nonReservedKeywords!default.parser.nonReservedKeywords) + (parser.nonReservedKeywordsToAdd!default.parser.nonReservedKeywordsToAdd) as keyword&gt; &lt;if keyword?index == 2&gt; &lt;{keyword}&gt; &lt;elseif keyword?index % 3 == 2&gt; | &lt;{keyword}&gt; &lt;if&gt; &lt;list&gt; ) } LITERALS &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; UNSIGNED_INTEGER_LITERAL: ([&quot;0&quot;-&quot;9&quot;])+ &gt; | &lt; APPROX_NUMERIC_LITERAL: (&lt;UNSIGNED_INTEGER_LITERAL&gt; | &lt;DECIMAL_NUMERIC_LITERAL&gt;) &lt;EXPONENT&gt; &gt; | &lt; DECIMAL_NUMERIC_LITERAL: ([&quot;0&quot;-&quot;9&quot;])+(&quot;.&quot;)?([&quot;0&quot;-&quot;9&quot;]) | &quot;.&quot;([&quot;0&quot;-&quot;9&quot;])+ &gt; | &lt; EXPONENT: [&quot;e&quot;,&quot;E&quot;] ([&quot;+&quot;,&quot;-&quot;])? ([&quot;0&quot;-&quot;9&quot;])+ &gt; | &lt; HEXDIGIT: [&quot;0&quot;-&quot;9&quot;,&quot;a&quot;-&quot;f&quot;,&quot;A&quot;-&quot;F&quot;] &gt; | &lt; WHITESPACE: [ &quot; &quot;,&quot;\t&quot;,&quot;\n&quot;,&quot;\r&quot;,&quot;\f&quot; ] &gt; | To improve error reporting, we allow all kinds of characters, not just hexits, in a binary string literal. &lt; BINARY_STRING_LITERAL: [&quot;x&quot;,&quot;X&quot;] &lt;QUOTE&gt; ( (~[&quot;'&quot;]) | (&quot;''&quot;)) &lt;QUOTE&gt; &gt; } All databases except BigQuery support standard single-quoted literals, which use single-quote as the escape character. &lt;DEFAULT, DQID, BTID&gt; TOKEN : { &lt; QUOTED_STRING: &lt;QUOTE&gt; ( (~[&quot;'&quot;]) | (&quot;''&quot;)) &lt;QUOTE&gt; &gt; | &lt; PREFIXED_STRING_LITERAL: (&quot;_&quot; &lt;CHARSETNAME&gt; | &quot;N&quot;) &lt;QUOTED_STRING&gt; &gt; | &lt; UNICODE_STRING_LITERAL: &quot;U&quot; &quot;&amp;&quot; &lt;QUOTED_STRING&gt; &gt; | &lt; CHARSETNAME: ([&quot;a&quot;-&quot;z&quot;,&quot;A&quot;-&quot;Z&quot;,&quot;0&quot;-&quot;9&quot;]) ([&quot;a&quot;-&quot;z&quot;,&quot;A&quot;-&quot;Z&quot;,&quot;0&quot;-&quot;9&quot;,&quot;:&quot;,&quot;.&quot;,&quot;-&quot;,&quot;_&quot;]) &gt; } BigQuery supports single- and double-quoted literals with back-slash as the escape character. &lt;BQID, BQHID&gt; TOKEN : { BigQuery-style double-quoted string, escaped using backslash &lt; BIG_QUERY_DOUBLE_QUOTED_STRING: &lt;DOUBLE_QUOTE&gt; ( (~[&quot;\\&quot;, &quot;\&quot;&quot;]) | (&quot;\\&quot; ~[]) ) &lt;DOUBLE_QUOTE&gt; &gt; | BigQuery-style single-quoted string, escaped using backslash &lt; BIG_QUERY_QUOTED_STRING: &lt;QUOTE&gt; ( (~[&quot;\\&quot;, &quot;'&quot;]) | (&quot;\\&quot; ~[]) ) &lt;QUOTE&gt; &gt; } &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; UNICODE_QUOTED_ESCAPE_CHAR: &lt;QUOTE&gt; (~[&quot;0&quot;-&quot;9&quot;,&quot;a&quot;-&quot;f&quot;,&quot;A&quot;-&quot;F&quot;,&quot;+&quot;,&quot;\&quot;&quot;,&quot; &quot;,&quot;\t&quot;,&quot;\n&quot;,&quot;\r&quot;,&quot;\f&quot;]) &lt;QUOTE&gt; &gt; } SEPARATORS &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; LPAREN: &quot;(&quot;&gt; | &lt; RPAREN: &quot;)&quot;&gt; &lt;if (parser.includeBraces!default.parser.includeBraces) &gt; | &lt; LBRACE_D: &quot;{&quot; (&quot; &quot;) [&quot;d&quot;,&quot;D&quot;] &gt; | &lt; LBRACE_T: &quot;{&quot; (&quot; &quot;) [&quot;t&quot;,&quot;T&quot;] &gt; | &lt; LBRACE_TS: &quot;{&quot; (&quot; &quot;) [&quot;t&quot;,&quot;T&quot;] [&quot;s&quot;,&quot;S&quot;] &gt; | &lt; LBRACE_FN: &quot;{&quot; (&quot; &quot;) [&quot;f&quot;,&quot;F&quot;] [&quot;n&quot;,&quot;N&quot;] &gt; | &lt; LBRACE: &quot;{&quot; &gt; | &lt; RBRACE: &quot;}&quot; &gt; &lt;else&gt; &lt;include &quot;@includesbraces.ftl&quot; &gt; &lt;if&gt; | &lt; LBRACKET: &quot;[&quot; &gt; | &lt; RBRACKET: &quot;]&quot; &gt; | &lt; SEMICOLON: &quot;;&quot; &gt; | &lt; DOT: &quot;.&quot; &gt; | &lt; COMMA: &quot;,&quot; &gt; } OPERATORS &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; EQ: &quot;=&quot; &gt; | &lt; GT: &quot;&gt;&quot; &gt; | &lt; LT: &quot;&lt;&quot; &gt; | &lt; HOOK: &quot;?&quot; &gt; | &lt; COLON: &quot;:&quot; &gt; | &lt; LE: &quot;&lt;=&quot; &gt; | &lt; GE: &quot;&gt;=&quot; &gt; | &lt; NE: &quot;&lt;&gt;&quot; &gt; | &lt; NE2: &quot;!=&quot; &gt; | &lt; PLUS: &quot;+&quot; &gt; | &lt; MINUS: &quot;-&quot; &gt; | &lt; STAR: &quot;&quot; &gt; | &lt; SLASH: &quot;&quot; &gt; | &lt; PERCENT_REMAINDER: &quot;%&quot; &gt; | &lt; CONCAT: &quot;||&quot; &gt; | &lt; NAMED_ARGUMENT_ASSIGNMENT: &quot;=&gt;&quot; &gt; | &lt; DOUBLE_PERIOD: &quot;..&quot; &gt; | &lt; QUOTE: &quot;'&quot; &gt; | &lt; DOUBLE_QUOTE: &quot;\&quot;&quot; &gt; | &lt; VERTICAL_BAR: &quot;|&quot; &gt; | &lt; CARET: &quot;^&quot; &gt; | &lt; DOLLAR: &quot;&quot; &gt; &lt;list (parser.binaryOperatorsTokens!default.parser.binaryOperatorsTokens) as operator&gt; | {operator} &lt;list&gt; } Lexical Descriptions TOKEN_MGR_DECLS : { final List&lt;Integer&gt; lexicalStateStack = new ArrayList&lt;Integer&gt;(); void pushState() { lexicalStateStack.add(curLexState); } void popState() { SwitchTo(lexicalStateStack.remove(lexicalStateStack.size() - 1)); } void beforeTableName() { if (curLexState == BQID) { pushState(); SwitchTo(BQHID); } } void afterTableName() { if (curLexState == BQHID) { popState(); } } &lt;if (parser.includeAdditionalDeclarations!default.parser.includeAdditionalDeclarations)&gt; &lt;include &quot;@includestokenManagerDeclarations.ftl&quot; &gt; &lt;if&gt; } Lexical states: DEFAULT: Identifiers are quoted in brackets, e.g. [My Identifier] DQID: Identifiers are double-quoted, e.g. &quot;My Identifier&quot; BTID: Identifiers are enclosed in back-ticks, e.g. `My Identifier` BQID: Identifiers are enclosed in back-ticks, e.g. `My Identifier`, and with the potential to shift into BQHID in contexts where table names are expected, and thus allow hyphen-separated identifiers as part of table names BQHID: Identifiers are enclosed in back-ticks, e.g. `My Identifier` and unquoted identifiers may contain hyphens, e.g. foo-bar IN_SINGLE_LINE_COMMENT: IN_FORMAL_COMMENT: IN_MULTI_LINE_COMMENT: DEFAULT, DQID, BTID, BQID are the 4 'normal states'. Behavior is identical except for how quoted identifiers are recognized. The BQHID state exists only at the start of a table name (e.g. immediately after FROM or INSERT INTO). As soon as an identifier is seen, the state shifts back to BTID. After a comment has completed, the lexer returns to the previous state, one of the 'normal states'. WHITE SPACE &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; SKIP : { &quot; &quot; | &quot;\t&quot; | &quot;\n&quot; | &quot;\r&quot; | &quot;\f&quot; } COMMENTS &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; HINT_BEG: &quot;+&quot;&gt; | &lt; COMMENT_END: &quot;&quot; &gt; } &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; MORE : { &lt;&quot;&quot; ~[&quot;&quot;]&gt; { pushState(); } : IN_FORMAL_COMMENT } &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; MORE : { &quot;&quot; { pushState(); } : IN_MULTI_LINE_COMMENT } &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; SKIP : { &lt;SINGLE_LINE_COMMENT: (&quot;&quot;|&quot;--&quot;)(~[&quot;\n&quot;,&quot;\r&quot;]) (&quot;\n&quot;|&quot;\r&quot;|&quot;\r\n&quot;)? &gt; } &lt;IN_FORMAL_COMMENT&gt; SPECIAL_TOKEN : { &lt;FORMAL_COMMENT: &lt;COMMENT_END&gt; &gt; { popState(); } } &lt;IN_MULTI_LINE_COMMENT&gt; SPECIAL_TOKEN : { &lt;MULTI_LINE_COMMENT: &lt;COMMENT_END&gt; &gt; { popState(); } } &lt;IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT&gt; MORE : { &lt; ~[] &gt; } IDENTIFIERS &lt;DEFAULT&gt; TOKEN : { &lt; BRACKET_QUOTED_IDENTIFIER: &quot;[&quot; ( (~[&quot;]&quot;,&quot;\n&quot;,&quot;\r&quot;]) | (&quot;]]&quot;) )+ &quot;]&quot; &gt; } &lt;DQID&gt; TOKEN : { &lt; QUOTED_IDENTIFIER: &quot;\&quot;&quot; ( (~[&quot;\&quot;&quot;,&quot;\n&quot;,&quot;\r&quot;]) | (&quot;\&quot;\&quot;&quot;) )+ &quot;\&quot;&quot; &gt; } &lt;BTID, BQID, BQHID&gt; TOKEN : { &lt; BACK_QUOTED_IDENTIFIER: &quot;`&quot; ( (~[&quot;`&quot;,&quot;\n&quot;,&quot;\r&quot;]) | (&quot;``&quot;) )+ &quot;`&quot; &gt; } &lt;BQHID&gt; TOKEN : { Per BigQuery: &quot;Project IDs must contain 6-63 lowercase letters, digits, or dashes. IDs must start with a letter and may not end with a dash.&quot; We do not restrict length, or prevent identifiers from ending in a dash. &lt; HYPHENATED_IDENTIFIER: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;|&quot;-&quot;) &gt; { popState(); } } &lt;DEFAULT, DQID, BTID, BQID&gt; TOKEN : { &lt; IDENTIFIER: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;) &gt; } &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; COLLATION_ID: (&lt;LETTER&gt;|&lt;DIGIT&gt;)+ (&lt;LETTER&gt;|&lt;DIGIT&gt;|&quot;:&quot;|&quot;.&quot;|&quot;-&quot;|&quot;_&quot;) &quot;&quot; (&lt;LETTER&gt;|&quot;_&quot;)+ (&quot;&quot; (&lt;LETTER&gt;|&lt;DIGIT&gt;|&quot;_&quot;)+)? &gt; | &lt; UNICODE_QUOTED_IDENTIFIER: &quot;U&quot; &quot;&amp;&quot; &lt;QUOTED_IDENTIFIER&gt; &gt; | &lt; LETTER: [ &quot;\u0024&quot;, &quot;\u0041&quot;-&quot;\u005a&quot;, &quot;\u005f&quot;, &quot;\u0061&quot;-&quot;\u007a&quot;, &quot;\u00c0&quot;-&quot;\u00d6&quot;, &quot;\u00d8&quot;-&quot;\u00f6&quot;, &quot;\u00f8&quot;-&quot;\u00ff&quot;, &quot;\u0100&quot;-&quot;\u1fff&quot;, &quot;\u3040&quot;-&quot;\u318f&quot;, &quot;\u3300&quot;-&quot;\u337f&quot;, &quot;\u3400&quot;-&quot;\u3d2d&quot;, &quot;\u4e00&quot;-&quot;\u9fff&quot;, &quot;\uf900&quot;-&quot;\ufaff&quot; ] &gt; | &lt; DIGIT: [ &quot;\u0030&quot;-&quot;\u0039&quot;, &quot;\u0660&quot;-&quot;\u0669&quot;, &quot;\u06f0&quot;-&quot;\u06f9&quot;, &quot;\u0966&quot;-&quot;\u096f&quot;, &quot;\u09e6&quot;-&quot;\u09ef&quot;, &quot;\u0a66&quot;-&quot;\u0a6f&quot;, &quot;\u0ae6&quot;-&quot;\u0aef&quot;, &quot;\u0b66&quot;-&quot;\u0b6f&quot;, &quot;\u0be7&quot;-&quot;\u0bef&quot;, &quot;\u0c66&quot;-&quot;\u0c6f&quot;, &quot;\u0ce6&quot;-&quot;\u0cef&quot;, &quot;\u0d66&quot;-&quot;\u0d6f&quot;, &quot;\u0e50&quot;-&quot;\u0e59&quot;, &quot;\u0ed0&quot;-&quot;\u0ed9&quot;, &quot;\u1040&quot;-&quot;\u1049&quot; ] &gt; } Special token to throw a wrench in the works. It is never valid in SQL, and so when it occurs, it causes the parser to print which tokens would have been valid at that point. Used by SqlAdvisor. &lt;DEFAULT, DQID, BTID, BQID, BQHID&gt; TOKEN : { &lt; BEL: [ &quot;\u0007&quot; ] &gt; } Defines a production which can never be accepted by the parser. In effect, it tells the parser, &quot;If you got here, you've gone too far.&quot; It is used as the default production for parser extension points; derived parsers replace it with a real production when they want to implement a particular extension point. void UnusedExtension() : { } { ( LOOKAHEAD({false}) &lt;ZONE&gt; ) }" />
      <item value="Sql Dynamic Param   " />
      <item value="Sql Dynamic Param" />
      <item value="Parses a dynamic parameter marker." />
      <item value="set Allow Bang Equal" />
      <item value="qlSchemaParserImplTokenManage" />
      <item value="Generated By:JavaCC: Do not edit this line. SqlSchemaParserImplTokenManager.java" />
      <item value="Sql Data Type Spec" />
      <item value="return" />
      <item value="parser" />
      <item value="INSTANCE" />
      <item value="Re Init" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="691" />
        <entry key="ENGLISH" value="692" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="HINDI" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1629704406766" />
  </component>
</application>